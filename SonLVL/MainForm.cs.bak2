using SonicRetro.SonLVL.API;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using System.Runtime.Serialization.Formatters.Binary;
using System.Windows.Forms;

namespace SonicRetro.SonLVL.GUI
{
	public partial class MainForm : Form
	{
		public static MainForm Instance { get; private set; }
		Settings Settings;
		readonly int pid;

		public MainForm()
		{
			Application.ThreadException += Application_ThreadException;
			Instance = this;
			pid = System.Diagnostics.Process.GetCurrentProcess().Id;
			if (Program.IsMonoRuntime)
				Log("Mono runtime detected.");
			Log("Operating system: " + Environment.OSVersion.ToString());
			LevelData.LogEvent += Log;
			LevelData.PaletteChangedEvent += LevelData_PaletteChangedEvent;
			InitializeComponent();
			if (Program.IsMonoRuntime)
				floorAngle.TextChanged += ColAngle_TextChanged;
		}

		const int ColorGrid = 64;

		void LevelData_PaletteChangedEvent()
		{
			LevelData.BmpPal.Entries.CopyTo(LevelImgPalette.Entries, 0);
			LevelImgPalette.Entries[LevelData.ColorTransparent] = LevelData.NewPalette[160];
			if (invertColorsToolStripMenuItem.Checked)
				for (int i = 0; i < 256; i++)
					LevelImgPalette.Entries[i] = LevelImgPalette.Entries[i].Invert();
			LevelImgPalette.Entries[LevelData.ColorWhite] = Color.White;
			LevelImgPalette.Entries[LevelData.ColorYellow] = Color.Yellow;
			LevelImgPalette.Entries[LevelData.ColorBlack] = Color.Black;
			LevelImgPalette.Entries[ColorGrid] = Settings.GridColor;
			ChunkSelector.Invalidate();
			DrawChunkPicture();
			chunkBlockEditor.Invalidate();
			DrawPalette();
			DrawTilePicture();
			TileSelector.Invalidate();
			DrawLevel();
		}

		void Application_ThreadException(object sender, System.Threading.ThreadExceptionEventArgs e)
		{
			Log(e.Exception.ToString().Split(new string[] { Environment.NewLine }, StringSplitOptions.None));
			File.WriteAllLines("SonLVL-RSDK.log", LogFile.ToArray());
			using (ErrorDialog ed = new ErrorDialog("Unhandled Exception " + e.Exception.GetType().Name + "\nLog file has been saved.\n\nDo you want to try to continue running?", true))
			{
				if (ed.ShowDialog(this) == DialogResult.Cancel)
					Close();
			}
		}

		class LevelStuff
		{
			public string FullName;
			public ToolStripMenuItem MenuItem;
			public RSDKv3_4.GameConfig.StageList.StageInfo Stage;
		}

		ImageAttributes imageTransparency = new ImageAttributes();
		Bitmap LevelBmp;
		Graphics LevelGfx, PalettePanelGfx;
		bool loaded;
		ushort SelectedChunk;
		List<Entry> SelectedItems;
		ObjectList ObjectSelect;
		Rectangle FGSelection, BGSelection;
		ColorPalette LevelImgPalette;
		int bglayer;
		double ZoomLevel = 1;
		byte ObjGrid = 0;
		bool objdrag = false;
		bool dragdrop = false;
		byte dragobj;
		Point dragpoint;
		bool selecting = false;
		Point selpoint;
		Point lastchunkpoint;
		Point lastmouse;
		internal LogWindow LogWindow;
		internal List<string> LogFile = new List<string>();
		List<LevelStuff> levelMenuItems;
		string levelname;
		Dictionary<char, HUDImage> HUDLetters, HUDNumbers;
		FindObjectsDialog findObjectsDialog;
		FindChunksDialog findFGChunksDialog;
		FindChunksDialog findBGChunksDialog;
		ReplaceChunksDialog replaceFGChunksDialog;
		ReplaceChunksDialog replaceBGChunksDialog;
		ReplaceChunkBlocksDialog replaceChunkBlocksDialog;
		List<LayoutSection> savedLayoutSections;
		List<Bitmap> savedLayoutSectionImages;
		MouseButtons chunkblockMouseDraw = MouseButtons.Left;
		MouseButtons chunkblockMouseSelect = MouseButtons.Right;

		internal void Log(params string[] lines)
		{
			lock (LogFile)
			{
				LogFile.AddRange(lines);
				if (LogWindow != null)
					LogWindow.Invoke(new MethodInvoker(LogWindow.UpdateLines));
			}
		}

		Tab CurrentTab
		{
			get { return (Tab)tabControl1.SelectedIndex; }
			set { tabControl1.SelectedIndex = (int)value; }
		}

		ArtTab CurrentArtTab
		{
			get { return (ArtTab)tabControl4.SelectedIndex; }
			set { tabControl4.SelectedIndex = (int)value; }
		}

		private void MainForm_Load(object sender, EventArgs e)
		{
			Settings = Settings.Load();
			imageTransparency.SetColorMatrix(new ColorMatrix() { Matrix33 = 0.75f }, ColorMatrixFlag.Default, ColorAdjustType.Bitmap);
			PalettePanelGfx = PalettePanel.CreateGraphics();
			string HUDpath = Path.Combine(Application.StartupPath, "HUD");
			HUDLetters = new Dictionary<char, HUDImage>();
			Dictionary<char, string> huditems = IniSerializer.Deserialize<Dictionary<char, string>>(Path.Combine(HUDpath, "HUD.ini"));
			foreach (KeyValuePair<char, string> item in huditems)
			{
				BitmapBits bmp = new BitmapBits(Path.Combine(HUDpath, item.Value + ".png"));
				if (bmp.OriginalFormat != PixelFormat.Format8bppIndexed)
					bmp.FixUIColors();
				HUDLetters.Add(item.Key, new HUDImage(bmp));
			}
			HUDNumbers = new Dictionary<char, HUDImage>();
			huditems = IniSerializer.Deserialize<Dictionary<char, string>>(Path.Combine(HUDpath, "HUDnum.ini"));
			foreach (KeyValuePair<char, string> item in huditems)
			{
				BitmapBits bmp = new BitmapBits(Path.Combine(HUDpath, item.Value + ".png"));
				if (bmp.OriginalFormat != PixelFormat.Format8bppIndexed)
					bmp.FixUIColors();
				HUDNumbers.Add(item.Key, new HUDImage(bmp));
			}
			objectsAboveHighPlaneToolStripMenuItem.Checked = Settings.ObjectsAboveHighPlane;
			hUDToolStripMenuItem.Checked = Settings.ShowHUD;
			invertColorsToolStripMenuItem.Checked = Settings.InvertColors;
			lowToolStripMenuItem.Checked = Settings.ViewLowPlane;
			highToolStripMenuItem.Checked = Settings.ViewHighPlane;
			switch (Settings.ViewCollision)
			{
				case CollisionPath.Path1:
					noneToolStripMenuItem1.Checked = false;
					path1ToolStripMenuItem.Checked = true;
					break;
				case CollisionPath.Path2:
					noneToolStripMenuItem1.Checked = false;
					path2ToolStripMenuItem.Checked = true;
					break;
			}
			anglesToolStripMenuItem.Checked = Settings.ViewAngles;
			enableGridToolStripMenuItem.Checked = Settings.ShowGrid;
			foreach (ToolStripMenuItem item in zoomToolStripMenuItem.DropDownItems)
				if (item.Text == Settings.ZoomLevel)
				{
					zoomToolStripMenuItem_DropDownItemClicked(this, new ToolStripItemClickedEventArgs(item));
					break;
				}
			objGridSizeDropDownButton_DropDownItemClicked(this, new ToolStripItemClickedEventArgs(objGridSizeDropDownButton.DropDownItems[Settings.ObjectGridSize]));
			includeObjectsWithForegroundSelectionToolStripMenuItem.Checked = Settings.IncludeObjectsInForegroundSelection;
			transparentBackgroundToolStripMenuItem.Checked = Settings.TransparentBackgroundExport;
			includeobjectsWithFGToolStripMenuItem.Checked = Settings.IncludeObjectsFG;
			exportArtcollisionpriorityToolStripMenuItem.Checked = Settings.ExportArtCollisionPriority;
			CurrentTab = Settings.CurrentTab;
			CurrentArtTab = Settings.CurrentArtTab;
			switchMouseButtonsInChunkAndBlockEditorsToolStripMenuItem.Checked = Settings.SwitchChunkBlockMouseButtons;
			switch (Settings.WindowMode)
			{
				case WindowMode.Maximized:
					WindowState = FormWindowState.Maximized;
					break;
				case WindowMode.Fullscreen:
					prevbnds = Bounds;
					prevstate = WindowState;
					TopMost = true;
					WindowState = FormWindowState.Normal;
					FormBorderStyle = FormBorderStyle.None;
					Bounds = Screen.FromControl(this).Bounds;
					break;
			}
			mainMenuStrip.Visible = Settings.ShowMenu;
			enableDraggingPaletteButton.Checked = Settings.EnableDraggingPalette;
			enableDraggingTilesButton.Checked = Settings.EnableDraggingTiles;
			enableDraggingChunksButton.Checked = Settings.EnableDraggingChunks;
			if (System.Diagnostics.Debugger.IsAttached)
				logToolStripMenuItem_Click(sender, e);
			if (Settings.MRUList == null)
				Settings.MRUList = new List<string>();
			List<string> mru = new List<string>();
			foreach (string item in Settings.MRUList)
			{
				if (File.Exists(item))
				{
					mru.Add(item);
					recentProjectsToolStripMenuItem.DropDownItems.Add(item.Replace("&", "&&"));
				}
			}
			Settings.MRUList = mru;
			if (mru.Count > 0) recentProjectsToolStripMenuItem.DropDownItems.Remove(noneToolStripMenuItem2);
			findObjectsDialog = new FindObjectsDialog();
			findFGChunksDialog = new FindChunksDialog();
			findBGChunksDialog = new FindChunksDialog();
			replaceFGChunksDialog = new ReplaceChunksDialog();
			replaceBGChunksDialog = new ReplaceChunksDialog();
			replaceChunkBlocksDialog = new ReplaceChunkBlocksDialog();
			if (Program.Arguments.Length > 0)
				LoadINI(Program.Arguments[0]);
		}

		private void MainForm_FormClosing(object sender, FormClosingEventArgs e)
		{
			if (loaded)
			{
				switch (MessageBox.Show(this, "Do you want to save?", Text, MessageBoxButtons.YesNoCancel, MessageBoxIcon.Question))
				{
					case DialogResult.Yes:
						saveToolStripMenuItem_Click(this, EventArgs.Empty);
						break;
					case DialogResult.Cancel:
						e.Cancel = true;
						break;
				}
			}
			if (Settings != null)
			{
				Settings.ShowHUD = hUDToolStripMenuItem.Checked;
				Settings.InvertColors = invertColorsToolStripMenuItem.Checked;
				if (path1ToolStripMenuItem.Checked)
					Settings.ViewCollision = CollisionPath.Path1;
				else if (path2ToolStripMenuItem.Checked)
					Settings.ViewCollision = CollisionPath.Path2;
				else
					Settings.ViewCollision = CollisionPath.None;
				Settings.ViewAngles = anglesToolStripMenuItem.Checked;
				Settings.ShowGrid = enableGridToolStripMenuItem.Checked;
				Settings.ZoomLevel = zoomToolStripMenuItem.DropDownItems.Cast<ToolStripMenuItem>().Single((a) => a.Checked).Text;
				Settings.ObjectGridSize = ObjGrid;
				Settings.IncludeObjectsInForegroundSelection = includeObjectsWithForegroundSelectionToolStripMenuItem.Checked;
				Settings.CurrentTab = CurrentTab;
				Settings.CurrentArtTab = CurrentArtTab;
				if (TopMost)
					Settings.WindowMode = WindowMode.Fullscreen;
				else if (WindowState == FormWindowState.Maximized)
					Settings.WindowMode = WindowMode.Maximized;
				else
					Settings.WindowMode = WindowMode.Normal;
				Settings.ShowMenu = mainMenuStrip.Visible;
				Settings.EnableDraggingPalette = enableDraggingPaletteButton.Checked;
				Settings.EnableDraggingTiles = enableDraggingTilesButton.Checked;
				Settings.EnableDraggingChunks = enableDraggingChunksButton.Checked;
				Settings.Save();
			}
		}

		private void LoadINI(string filename)
		{
			try
			{
				LevelData.LoadGame(filename);
			}
			catch (Exception ex)
			{
				using (LoadErrorDialog ed = new LoadErrorDialog(false, ex.GetType().Name + ": " + ex.Message))
					ed.ShowDialog(this);
				return;
			}
			using (OpenFileDialog dlg = new OpenFileDialog()
			{
				DefaultExt = "ini",
				Filter = "Mod INI Files|mod.ini|All Files|*.*",
				Title = "Select the mod you want to edit.",
				RestoreDirectory = true
			})
				if (dlg.ShowDialog(this) == DialogResult.OK)
				{
					try
					{
						LevelData.LoadMod(dlg.FileName);
					}
					catch (Exception ex)
					{
						using (LoadErrorDialog ed = new LoadErrorDialog(false, ex.GetType().Name + ": " + ex.Message))
							ed.ShowDialog(this);
						return;
					}
					levelMenuItems = new List<LevelStuff>();
					List<List<RSDKv3_4.GameConfig.StageList.StageInfo>>[] groups = new List<List<RSDKv3_4.GameConfig.StageList.StageInfo>>[4];
					for (int i = 0; i < 4; i++)
					{
						groups[i] = new List<List<RSDKv3_4.GameConfig.StageList.StageInfo>>();
						List<RSDKv3_4.GameConfig.StageList.StageInfo> curgrp = null;
						foreach (var item in LevelData.GameConfig.stageLists[i].list)
							if (item.highlighted)
							{
								curgrp = new List<RSDKv3_4.GameConfig.StageList.StageInfo>() { item };
								groups[i].Add(curgrp);
							}
							else
								curgrp.Add(item);
					}
					for (int i = 0; i < 4; i++)
					{
						ToolStripMenuItem parent = (ToolStripMenuItem)changeLevelToolStripMenuItem.DropDownItems[i];
						parent.DropDownItems.Clear();
						foreach (var grp in groups[i])
						{
							if (grp.Count > 1)
							{
								string basename = grp[0].name.Substring(0, grp.Skip(1).Max(a => a.name.Length));
								var par2 = new ToolStripMenuItem(basename.Trim());
								parent.DropDownItems.Add(par2);
								foreach (var item in grp)
									if (!string.IsNullOrEmpty(item.name))
									{
										string name = item.name;
										string text = item.name;
										if (item.highlighted)
											text = text.Remove(0, basename.Length);
										else
											name = basename + name;
										LevelStuff ls = new LevelStuff() { FullName = name, Stage = item };
										ToolStripMenuItem ts = new ToolStripMenuItem(text, null, new EventHandler(LevelToolStripMenuItem_Clicked)) { Tag = ls };
										ls.MenuItem = ts;
										levelMenuItems.Add(ls);
										par2.DropDownItems.Add(ts);
									}
							}
							else if (!string.IsNullOrEmpty(grp[0].name))
							{
								LevelStuff ls = new LevelStuff() { FullName = grp[0].name, Stage = grp[0] };
								ToolStripMenuItem ts = new ToolStripMenuItem(grp[0].name, null, new EventHandler(LevelToolStripMenuItem_Clicked)) { Tag = ls };
								ls.MenuItem = ts;
								levelMenuItems.Add(ls);
								parent.DropDownItems.Add(ts);
							}
						}
					}
					switch (LevelData.RSDKVer)
					{
						case EngineVersion.V4:
							Icon = Properties.Resources.Tailsmon2;
							break;
						case EngineVersion.V3:
							Icon = Properties.Resources.clockmon;
							break;
						default:
							throw new NotImplementedException("Game type is not supported!");
					}
					Text = "SonLVL-RSDK - " + LevelData.GameConfig.gameTitle;
					if (Settings.MRUList.Count == 0)
						recentProjectsToolStripMenuItem.DropDownItems.Remove(noneToolStripMenuItem2);
					if (Settings.MRUList.Contains(filename))
					{
						recentProjectsToolStripMenuItem.DropDownItems.RemoveAt(Settings.MRUList.IndexOf(filename));
						Settings.MRUList.Remove(filename);
					}
					Settings.MRUList.Insert(0, filename);
					recentProjectsToolStripMenuItem.DropDownItems.Insert(0, new ToolStripMenuItem(filename));
				}
		}

		#region Main Menu
		#region File Menu
		private void openToolStripMenuItem_Click(object sender, EventArgs e)
		{
			if (loaded)
			{
				switch (MessageBox.Show(this, "Do you want to save?", Text, MessageBoxButtons.YesNoCancel, MessageBoxIcon.Question))
				{
					case DialogResult.Yes:
						saveToolStripMenuItem_Click(this, EventArgs.Empty);
						break;
					case DialogResult.Cancel:
						return;
				}
			}
			using (OpenFileDialog a = new OpenFileDialog()
			{
				DefaultExt = "exe",
				Filter = "EXE Files|*.exe|All Files|*.*",
				Title = "Select your game's EXE"
			})
				if (a.ShowDialog(this) == DialogResult.OK)
				{
					loaded = false;
					LoadINI(a.FileName);
				}
		}

		private void LevelToolStripMenuItem_Clicked(object sender, EventArgs e)
		{
			if (loaded)
			{
				fileToolStripMenuItem.DropDown.Hide();
				switch (MessageBox.Show(this, "Do you want to save?", Text, MessageBoxButtons.YesNoCancel, MessageBoxIcon.Question))
				{
					case DialogResult.Yes:
						saveToolStripMenuItem_Click(this, EventArgs.Empty);
						break;
					case DialogResult.Cancel:
						return;
				}
			}
			loaded = false;
			foreach (var item in levelMenuItems)
				item.MenuItem.Checked = false;
			((ToolStripMenuItem)sender).Checked = true;
			Enabled = false;
			UseWaitCursor = true;
			levelname = ((LevelStuff)((ToolStripMenuItem)sender).Tag).FullName;
			Text = $"SonLVL-RSDK - {LevelData.GameConfig.gameTitle} - Loading {levelname}...";
#if !DEBUG
			initerror = null;
			backgroundLevelLoader.RunWorkerAsync(((ToolStripMenuItem)sender).Tag);
#else
			backgroundLevelLoader_DoWork(null, new DoWorkEventArgs(((ToolStripMenuItem)sender).Tag));
			backgroundLevelLoader_RunWorkerCompleted(null, null);
#endif
		}

		Exception initerror = null;
		private void backgroundLevelLoader_DoWork(object sender, DoWorkEventArgs e)
		{
#if !DEBUG
			try
#endif
			{
				SelectedChunk = 0;
				LevelData.LoadLevel(((LevelStuff)e.Argument).Stage);
				LevelImgPalette = new Bitmap(1, 1, PixelFormat.Format8bppIndexed).Palette;
				LevelData.BmpPal.Entries.CopyTo(LevelImgPalette.Entries, 0);
				LevelImgPalette.Entries[LevelData.ColorTransparent] = LevelData.NewPalette[160];
				LevelImgPalette.Entries[LevelData.ColorWhite] = Color.White;
				LevelImgPalette.Entries[LevelData.ColorYellow] = Color.Yellow;
				LevelImgPalette.Entries[LevelData.ColorBlack] = Color.Black;
				LevelImgPalette.Entries[ColorGrid] = Settings.GridColor;
			}
#if !DEBUG
			catch (Exception ex) { initerror = ex; }
#endif
		}

		private void backgroundLevelLoader_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
		{
			if (initerror != null)
			{
				Log(initerror.ToString().Split(new string[] { Environment.NewLine }, StringSplitOptions.None));
				File.WriteAllLines("SonLVL-RSDK.log", LogFile.ToArray());
				string msg = initerror.GetType().Name + ": " + initerror.Message;
				if (initerror is AggregateException ae)
				{
					msg += " =>";
					foreach (Exception ex in ae.InnerExceptions)
						msg += Environment.NewLine + ex.GetType().Name + ": " + ex.Message;
				}
				using (LoadErrorDialog ed = new LoadErrorDialog(true, msg))
					ed.ShowDialog(this);
				Text = "SonLVL-RSDK - " + LevelData.GameConfig.gameTitle;
				Enabled = true;
				return;
			}
			Log("Load completed.");
			ChunkSelector.Images = LevelData.CompChunkBmps;
			ChunkSelector.SelectedIndex = 0;
			flipChunkHButton.Enabled = flipChunkVButton.Enabled = true;
			remapChunksButton.Enabled = remapTilesButton.Enabled = true;
			TileSelector.Images = LevelData.NewTileBmps;
			TileSelector.SelectedIndex = 0;
			TileSelector.ChangeSize();
			if (ObjectSelect == null)
			{
				ObjectSelect = new ObjectList();
				ObjectSelect.listView1.SelectedIndexChanged += new EventHandler(ObjectSelect_listView1_SelectedIndexChanged);
				ObjectSelect.listView2.SelectedIndexChanged += new EventHandler(ObjectSelect_listView2_SelectedIndexChanged);
			}
			ObjectSelect.listView1.Items.Clear();
			ObjectSelect.imageList1.Images.Clear();
			objectTypeList.Items.Clear();
			objectTypeImages.Images.Clear();
			foreach (KeyValuePair<byte, ObjectDefinition> item in LevelData.ObjTypes)
			{
				Bitmap image = item.Value.Image.GetBitmap().ToBitmap(LevelData.BmpPal);
				ObjectSelect.imageList1.Images.Add(image.Resize(ObjectSelect.imageList1.ImageSize));
				ObjectSelect.listView1.Items.Add(new ListViewItem(item.Value.Name, ObjectSelect.imageList1.Images.Count - 1) { Tag = item.Key });
				objectTypeImages.Images.Add(image.Resize(objectTypeImages.ImageSize));
				objectTypeList.Items.Add(new ListViewItem(item.Value.Name, objectTypeImages.Images.Count - 1) { Tag = item.Key });
			}
			ObjectSelect.listView2.Items.Clear();
			ObjectSelect.imageList2.Images.Clear();
			Text = "SonLVL-RSDK - " + LevelData.GameConfig + " - " + this.levelname;
			UpdateScrollBars();
			objectPanel.HScrollValue = 0;
			objectPanel.HScrollSmallChange = 16;
			objectPanel.HScrollLargeChange = 128;
			objectPanel.VScrollValue = 0;
			objectPanel.VScrollSmallChange = 16;
			objectPanel.VScrollLargeChange = 128;
			objectPanel.HScrollEnabled = true;
			objectPanel.VScrollEnabled = true;
			foregroundPanel.HScrollValue = 0;
			foregroundPanel.HScrollSmallChange = 16;
			foregroundPanel.HScrollLargeChange = 128;
			foregroundPanel.VScrollValue = 0;
			foregroundPanel.VScrollSmallChange = 16;
			foregroundPanel.VScrollLargeChange = 128;
			foregroundPanel.HScrollEnabled = true;
			foregroundPanel.VScrollEnabled = true;
			backgroundPanel.HScrollValue = 0;
			backgroundPanel.HScrollSmallChange = 16;
			backgroundPanel.HScrollLargeChange = 128;
			backgroundPanel.VScrollValue = 0;
			backgroundPanel.VScrollSmallChange = 16;
			backgroundPanel.VScrollLargeChange = 128;
			backgroundPanel.HScrollEnabled = true;
			backgroundPanel.VScrollEnabled = true;
			colorEditingPanel.Enabled = true;
			paletteToolStrip.Enabled = true;
			loaded = true;
			SelectedItems = new List<Entry>();
			saveToolStripMenuItem.Enabled = true;
			editToolStripMenuItem.Enabled = true;
			exportToolStripMenuItem.Enabled = true;
			if (invertColorsToolStripMenuItem.Checked)
				for (int i = 0; i < 256; i++)
					LevelImgPalette.Entries[i] = LevelImgPalette.Entries[i].Invert();
			findNextToolStripMenuItem.Enabled = findPreviousToolStripMenuItem.Enabled = false;
			string levelname = this.levelname;
			foreach (char c in Path.GetInvalidFileNameChars())
				levelname = levelname.Replace(c, '_');
			if (File.Exists(levelname + ".sls"))
				using (FileStream fs = File.OpenRead(levelname + ".sls"))
					savedLayoutSections = (List<LayoutSection>)new BinaryFormatter().Deserialize(fs);
			else
				savedLayoutSections = new List<LayoutSection>();
			savedLayoutSectionImages = new List<Bitmap>();
			layoutSectionListBox.Items.Clear();
			layoutSectionListBox.BeginUpdate();
			foreach (LayoutSection sec in savedLayoutSections)
			{
				layoutSectionListBox.Items.Add(sec.Name);
				savedLayoutSectionImages.Add(MakeLayoutSectionImage(sec));
			}
			layoutSectionListBox.EndUpdate();
			foundobjs = null;
			SelectedObjectChanged();
			ChunkID.Maximum = LevelData.NewChunks.chunkList.Length - 1;
			TileID.Maximum = LevelData.NewTiles.Length - 1;
			ChunkCount.Text = LevelData.NewChunks.chunkList.Length.ToString("X");
			TileCount.Text = LevelData.NewTiles.Length.ToString("X");
			deleteUnusedTilesToolStripButton.Enabled = deleteUnusedChunksToolStripButton.Enabled =
				removeDuplicateTilesToolStripButton.Enabled = removeDuplicateChunksToolStripButton.Enabled =
				replaceChunkBlocksToolStripButton.Enabled = replaceBackgroundToolStripButton.Enabled = replaceForegroundToolStripButton.Enabled =
				clearBackgroundToolStripButton.Enabled = clearForegroundToolStripButton.Enabled = usageCountsToolStripMenuItem.Enabled = true;
#if !DEBUG
			loadingAnimation1.Hide();
#endif
			Enabled = true;
			UseWaitCursor = false;
			DrawLevel();
		}

		private Bitmap MakeLayoutSectionImage(LayoutSection sec)
		{
			int w = sec.Layout.GetLength(0), h = sec.Layout.GetLength(1);
			BitmapBits bmp = new BitmapBits(w * 128, h * 128);
			for (int y = 0; y < h; y++)
				for (int x = 0; x < w; x++)
					if (sec.Layout[x, y] < LevelData.NewChunks.chunkList.Length)
						bmp.DrawSpriteLow(LevelData.ChunkSprites[sec.Layout[x, y]], x * 128, y * 128);
			foreach (Entry ent in sec.Objects)
			{
				ent.UpdateSprite();
				bmp.DrawSprite(ent.Sprite, 0, 0);
			}
			for (int y = 0; y < h; y++)
				for (int x = 0; x < w; x++)
					if (sec.Layout[x, y] < LevelData.NewChunks.chunkList.Length)
						bmp.DrawSpriteHigh(LevelData.ChunkSprites[sec.Layout[x, y]], x * 128, y * 128);
			return LevelData.BitmapBitsToBitmap(bmp);
		}

		private void saveToolStripMenuItem_Click(object sender, EventArgs e)
		{
			LevelData.SaveLevel();
		}

		private void buildAndRunToolStripMenuItem_Click(object sender, EventArgs e)
		{
			if (LevelData.Scene != null)
				saveToolStripMenuItem_Click(sender, e);
			System.Diagnostics.Process.Start(new System.Diagnostics.ProcessStartInfo(LevelData.EXEFile) { WorkingDirectory = Path.GetDirectoryName(LevelData.EXEFile) });
		}

		private void recentProjectsToolStripMenuItem_DropDownItemClicked(object sender, ToolStripItemClickedEventArgs e)
		{
			loaded = false;
			LoadINI(Settings.MRUList[recentProjectsToolStripMenuItem.DropDownItems.IndexOf(e.ClickedItem)]);
		}

		private void exitToolStripMenuItem_Click(object sender, EventArgs e)
		{
			Close();
		}
		#endregion

		#region Edit Menu
		#endregion

		#region View Menu
		private void includeObjectsWithFGToolStripMenuItem_CheckedChanged(object sender, EventArgs e)
		{
			Settings.IncludeObjectsFG = includeobjectsWithFGToolStripMenuItem.Checked;
			DrawLevel();
		}

		private void objectsAboveHighPlaneToolStripMenuItem_Click(object sender, EventArgs e)
		{
			objectsAboveHighPlaneToolStripMenuItem.Checked = !objectsAboveHighPlaneToolStripMenuItem.Checked;
			DrawLevel();
		}

		private void invertColorsToolStripMenuItem_Click(object sender, EventArgs e)
		{
			LevelData_PaletteChangedEvent();
		}

		private void lowToolStripMenuItem_Click(object sender, EventArgs e)
		{
			DrawLevel();
		}

		private void highToolStripMenuItem_Click(object sender, EventArgs e)
		{
			DrawLevel();
		}

		private void collisionToolStripMenuItem_DropDownItemClicked(object sender, ToolStripItemClickedEventArgs e)
		{
			if (collisionToolStripMenuItem.DropDownItems.IndexOf(e.ClickedItem) < 3)
			{
				bool angles = anglesToolStripMenuItem.Checked;
				foreach (ToolStripItem item in collisionToolStripMenuItem.DropDownItems)
					if (item is ToolStripMenuItem item1)
						item1.Checked = false;
				((ToolStripMenuItem)e.ClickedItem).Checked = true;
				anglesToolStripMenuItem.Checked = angles;
				DrawLevel();
			}
		}

		private void anglesToolStripMenuItem_Click(object sender, EventArgs e)
		{
			anglesToolStripMenuItem.Checked = !anglesToolStripMenuItem.Checked;
			DrawLevel();
		}

		private void gridColorToolStripMenuItem_Click(object sender, EventArgs e)
		{
			ColorDialog a = new ColorDialog
			{
				AllowFullOpen = true,
				AnyColor = true,
				FullOpen = true,
				SolidColorOnly = true,
				Color = Settings.GridColor
			};
			if (cols != null)
				a.CustomColors = cols;
			if (a.ShowDialog() == DialogResult.OK)
			{
				Settings.GridColor = a.Color;
				if (loaded)
				{
					LevelImgPalette.Entries[ColorGrid] = a.Color;
					DrawLevel();
				}
			}
			cols = a.CustomColors;
			a.Dispose();
		}

		private void zoomToolStripMenuItem_DropDownItemClicked(object sender, ToolStripItemClickedEventArgs e)
		{
			foreach (ToolStripMenuItem item in zoomToolStripMenuItem.DropDownItems)
				item.Checked = false;
			((ToolStripMenuItem)e.ClickedItem).Checked = true;
			switch (zoomToolStripMenuItem.DropDownItems.IndexOf(e.ClickedItem))
			{
				case 0: // 1/8x
					ZoomLevel = 0.125;
					break;
				case 1: // 1/4x
					ZoomLevel = 0.25;
					break;
				case 2: // 1/2x
					ZoomLevel = 0.5;
					break;
				default:
					ZoomLevel = zoomToolStripMenuItem.DropDownItems.IndexOf(e.ClickedItem) - 2;
					break;
			}
			if (!loaded) return;
			loaded = false;
			UpdateScrollBars();
			loaded = true;
			DrawLevel();
		}

		private void logToolStripMenuItem_Click(object sender, EventArgs e)
		{
			LogWindow = new LogWindow();
			LogWindow.Show(this);
			logToolStripMenuItem.Enabled = false;
		}
		#endregion

		#region Export Menu
		private void pNGToolStripMenuItem_Click(object sender, EventArgs e)
		{
			using (SaveFileDialog a = new SaveFileDialog() { DefaultExt = "png", Filter = "PNG Files|*.png", RestoreDirectory = true })
				if (a.ShowDialog(this) == DialogResult.OK)
				{
					BitmapBits bmp = new BitmapBits(16 * 8, 16 * 8);
					for (int y = 0; y < 16; y++)
						for (int x = 0; x < 16; x++)
							bmp.FillRectangle((byte)((y * 16) + x), x * 8, y * 8, 8, 8);
					bmp.ToBitmap(LevelData.NewPalette).Save(a.FileName);
				}
		}

		private void yYCHRToolStripMenuItem_Click(object sender, EventArgs e)
		{
			using (SaveFileDialog a = new SaveFileDialog() { DefaultExt = "act", Filter = "Palette Files|*.act", RestoreDirectory = true })
				if (a.ShowDialog(this) == DialogResult.OK)
					using (FileStream str = File.Create(a.FileName))
					using (BinaryWriter bw = new BinaryWriter(str))
						for (int i = 0; i < 256; i++)
						{
							bw.Write(LevelData.NewPalette[i].R);
							bw.Write(LevelData.NewPalette[i].G);
							bw.Write(LevelData.NewPalette[i].B);
						}
		}

		private void jASCPALToolStripMenuItem_Click(object sender, EventArgs e)
		{
			exportToolStripMenuItem.DropDown.Hide();
			using (SaveFileDialog a = new SaveFileDialog() { DefaultExt = "pal", Filter = "JASC-PAL Files|*.pal;*.PspPalette", RestoreDirectory = true })
				if (a.ShowDialog(this) == DialogResult.OK)
					using (StreamWriter writer = File.CreateText(a.FileName))
					{
						writer.WriteLine("JASC-PAL");
						writer.WriteLine("0100");
						writer.WriteLine("256");
						for (int i = 0; i < 256; i++)
							writer.WriteLine("{0} {1} {2}", LevelData.NewPalette[i].R, LevelData.NewPalette[i].G, LevelData.NewPalette[i].B);
						writer.Close();
					}
		}

		private void tilesToolStripMenuItem_DropDownItemClicked(object sender, ToolStripItemClickedEventArgs e)
		{
			exportToolStripMenuItem.DropDown.Hide();
			using (FolderBrowserDialog a = new FolderBrowserDialog() { SelectedPath = Environment.CurrentDirectory })
				if (a.ShowDialog() == DialogResult.OK)
					for (int i = 0; i < LevelData.NewTileBmps.Length; i++)
						LevelData.NewTileBmps[i]
							.Save(Path.Combine(a.SelectedPath,
							(useHexadecimalIndexesToolStripMenuItem.Checked ? i.ToString("X2") : i.ToString()) + ".png"));
		}

		private void chunksToolStripMenuItem_Click(object sender, EventArgs e)
		{
			if (!highToolStripMenuItem.Checked && !lowToolStripMenuItem.Checked && !path1ToolStripMenuItem.Checked && !path2ToolStripMenuItem.Checked)
			{
				MessageBox.Show(this, "Cannot export chunks with nothing visible.", Text, MessageBoxButtons.OK, MessageBoxIcon.Warning);
				return;
			}
			using (FolderBrowserDialog a = new FolderBrowserDialog() { SelectedPath = Environment.CurrentDirectory })
				if (a.ShowDialog() == DialogResult.OK)
				{
					ColorPalette pal;
					using (Bitmap bmp = new Bitmap(1, 1, PixelFormat.Format8bppIndexed))
						pal = bmp.Palette;
					LevelData.NewPalette.CopyTo(pal.Entries, 0);
					if (transparentBackgroundToolStripMenuItem.Checked)
						pal.Entries[0] = Color.Transparent;
					for (int i = 0; i < LevelData.NewChunks.chunkList.Length; i++)
					{
						BitmapBits bits = null;
						string pathBase = Path.Combine(a.SelectedPath, useHexadecimalIndexesToolStripMenuItem.Checked ? i.ToString("X2") : i.ToString());
						if (exportArtcollisionpriorityToolStripMenuItem.Checked)
						{
							bits = new BitmapBits(128, 128);
							bits.DrawSprite(LevelData.ChunkSprites[i]);
							bits.ToBitmap(pal).Save(pathBase + ".png");
								bits = new BitmapBits(LevelData.ChunkColBmpBits[i][0]);
								bits.UnfixUIColors();
								bits.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col1.png");
								bits = new BitmapBits(LevelData.ChunkColBmpBits[i][1]);
								bits.UnfixUIColors();
								bits.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col2.png");
							bits = new BitmapBits(128, 128);
							for (int cy = 0; cy < 128 / 16; cy++)
								for (int cx = 0; cx < 128 / 16; cx++)
									if (LevelData.NewChunks.chunkList[i].tiles[cy][cx].visualPlane == RSDKv3_4.Tiles128x128.Block.Tile.VisualPlanes.High)
										bits.FillRectangle(1, cx * 16, cy * 16, 16, 16);
							bits.ToBitmap1bpp(Color.Black, Color.White).Save(pathBase + "_pri.png");
						}
						else
						{
							bits = new BitmapBits(128, 128);
							if (highToolStripMenuItem.Checked & lowToolStripMenuItem.Checked)
								bits.DrawSprite(LevelData.ChunkSprites[i]);
							else if (lowToolStripMenuItem.Checked)
								bits.DrawSpriteLow(LevelData.ChunkSprites[i]);
							else if (highToolStripMenuItem.Checked)
								bits.DrawSpriteHigh(LevelData.ChunkSprites[i]);
							if (path1ToolStripMenuItem.Checked)
								bits.DrawBitmapComposited(LevelData.ChunkColBmpBits[i][0], 0, 0);
							else if (path2ToolStripMenuItem.Checked)
								bits.DrawBitmapComposited(LevelData.ChunkColBmpBits[i][1], 0, 0);
							bits.ToBitmap(pal).Save(pathBase + ".png");
						}
					}
				}
		}

		private void solidityMapsToolStripMenuItem_Click(object sender, EventArgs e)
		{
			using (FolderBrowserDialog a = new FolderBrowserDialog() { SelectedPath = Environment.CurrentDirectory })
				if (a.ShowDialog() == DialogResult.OK)
					for (int i = 0; i < LevelData.NewColBmpBits[0].Length; i++)
					{
						LevelData.NewColBmpBits[0][i].ToBitmap1bpp(Color.Transparent, Color.White).Save(Path.Combine(a.SelectedPath,
							"0_" + (useHexadecimalIndexesToolStripMenuItem.Checked ? i.ToString("X2") : i.ToString()) + ".png"));
						LevelData.NewColBmpBits[1][i].ToBitmap1bpp(Color.Transparent, Color.White).Save(Path.Combine(a.SelectedPath,
							"1_" + (useHexadecimalIndexesToolStripMenuItem.Checked ? i.ToString("X2") : i.ToString()) + ".png"));
					}
		}

		private void foregroundToolStripMenuItem_Click(object sender, EventArgs e)
		{
			using (SaveFileDialog a = new SaveFileDialog()
			{
				DefaultExt = "png",
				Filter = "PNG Files|*.png",
				RestoreDirectory = true
			})
				if (a.ShowDialog() == DialogResult.OK)
				{
					if (exportArtcollisionpriorityToolStripMenuItem.Checked)
					{
						string pathBase = Path.Combine(Path.GetDirectoryName(a.FileName), Path.GetFileNameWithoutExtension(a.FileName));
						string pathExt = Path.GetExtension(a.FileName);
						BitmapBits bmp = LevelData.DrawForeground(null, false, false, true, true, false, false);
						Bitmap res = bmp.ToBitmap();
						ColorPalette pal = res.Palette;
						LevelData.NewPalette.CopyTo(pal.Entries, 0);
						if (transparentBackgroundToolStripMenuItem.Checked)
							pal.Entries[0] = Color.Transparent;
						res.Palette = pal;
						res.Save(a.FileName);
						bmp = LevelData.DrawForeground(null, false, false, false, false, true, false);
						bmp.UnfixUIColors();
						bmp.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col1" + pathExt);
						bmp = LevelData.DrawForeground(null, false, false, false, false, false, true);
						bmp.UnfixUIColors();
						bmp.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col2" + pathExt);
						bmp.Clear();
						for (int ly = 0; ly < LevelData.FGHeight; ly++)
							for (int lx = 0; lx < LevelData.FGWidth; lx++)
							{
								if (LevelData.Scene.layout[ly][lx] >= LevelData.NewChunks.chunkList.Length) continue;
								RSDKv3_4.Tiles128x128.Block cnk = LevelData.NewChunks.chunkList[LevelData.Scene.layout[ly][lx]];
								for (int cy = 0; cy < 128 / 16; cy++)
									for (int cx = 0; cx < 128 / 16; cx++)
										if (cnk.tiles[cy][cx].visualPlane == RSDKv3_4.Tiles128x128.Block.Tile.VisualPlanes.High)
											bmp.FillRectangle(1, lx * 128 + cx * 16, ly * 128 + cy * 16, 16, 16);
							}
						bmp.ToBitmap1bpp(Color.Black, Color.White).Save(pathBase + "_pri" + pathExt);
					}
					else
					{
						BitmapBits bmp = LevelData.DrawForeground(null, includeobjectsWithFGToolStripMenuItem.Checked, objectsAboveHighPlaneToolStripMenuItem.Checked, lowToolStripMenuItem.Checked, highToolStripMenuItem.Checked, path1ToolStripMenuItem.Checked, path2ToolStripMenuItem.Checked);
						using (Bitmap res = bmp.ToBitmap(LevelImgPalette))
							res.Save(a.FileName);
					}
				}
		}

		private void backgroundToolStripMenuItem_Click(object sender, EventArgs e)
		{
			/*using (SaveFileDialog a = new SaveFileDialog()
			{
				DefaultExt = "png",
				Filter = "PNG Files|*.png",
				RestoreDirectory = true
			})
				if (a.ShowDialog() == DialogResult.OK)
				{
					if (exportArtcollisionpriorityToolStripMenuItem.Checked)
					{
						string pathBase = Path.Combine(Path.GetDirectoryName(a.FileName), Path.GetFileNameWithoutExtension(a.FileName));
						string pathExt = Path.GetExtension(a.FileName);
						BitmapBits bmp = LevelData.DrawBackground(null, true, true, false, false);
						for (int i = 0; i < bmp.Bits.Length; i++)
							if (bmp.Bits[i] == 0)
								bmp.Bits[i] = 32;
						Bitmap res = bmp.ToBitmap();
						ColorPalette pal = res.Palette;
						for (int i = 0; i < 64; i++)
							pal.Entries[i] = LevelData.PaletteToColor(i / 16, i % 16, transparentBackgroundToolStripMenuItem.Checked);
						pal.Entries.Fill(Color.Black, 64, 192);
						res.Palette = pal;
						res.Save(a.FileName);
						bool dualPath = false;
						switch (LevelData.Level.ChunkFormat)
						{
							case EngineVersion.S2:
							case EngineVersion.S2NA:
							case EngineVersion.S3K:
							case EngineVersion.SKC:
								dualPath = !Object.ReferenceEquals(LevelData.ColInds1, LevelData.ColInds2);
								break;
						}
						if (dualPath)
						{
							bmp = LevelData.DrawBackground(null, false, false, true, false);
							bmp.UnfixUIColors();
							bmp.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col1" + pathExt);
							bmp = LevelData.DrawBackground(null, false, false, false, true);
							bmp.UnfixUIColors();
							bmp.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col2" + pathExt);
						}
						else if (LevelData.LayoutFormat.HasLoopFlag && LevelData.Layout.BGLoop.OfType<bool>().Any(b => b))
						{
							bmp = LevelData.DrawBackground(null, false, false, true, false);
							bmp.UnfixUIColors();
							bmp.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col1" + pathExt);
							ushort[,] copy = (ushort[,])LevelData.Layout.BGLayout.Clone();
							for (int y = 0; y < LevelData.BGHeight; y++)
								for (int x = 0; x < LevelData.BGWidth; x++)
									if (LevelData.Layout.BGLoop[x, y])
										LevelData.Background.layers[bglayer].layout[y][x]++;
							bmp = LevelData.DrawBackground(null, false, false, true, false);
							bmp.UnfixUIColors();
							bmp.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col2" + pathExt);
							LevelData.Layout.BGLayout = copy;
						}
						else
						{
							bmp = LevelData.DrawBackground(null, false, false, true, false);
							bmp.UnfixUIColors();
							bmp.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col" + pathExt);
						}
						bmp.Clear();
						for (int ly = 0; ly < LevelData.BGHeight; ly++)
							for (int lx = 0; lx < LevelData.BGWidth; lx++)
							{
								if (LevelData.Background.layers[bglayer].layout[ly][lx] >= LevelData.NewChunks.chunkList.Length) continue;
								Chunk cnk = LevelData.NewChunks.chunkList[LevelData.Background.layers[bglayer].layout[ly][lx]];
								for (int cy = 0; cy < 128 / 16; cy++)
									for (int cx = 0; cx < 128 / 16; cx++)
									{
										if (cnk.tiles[cy][cx].tileIndex >= LevelData.NewTiles.Length) continue;
										Block blk = LevelData.NewTiles[cnk.tiles[cy][cx].tileIndex];
										for (int by = 0; by < 2; by++)
											for (int bx = 0; bx < 2; bx++)
												if (blk.Tiles[bx, by].Priority)
													bmp.FillRectangle(1, lx * 128 + cx * 16 + bx * 8, ly * 128 + cy * 16 + by * 8, 8, 8);
									}
							}
						bmp.ToBitmap1bpp(Color.Black, Color.White).Save(pathBase + "_pri" + pathExt);
					}
					else
					{
						BitmapBits bmp = LevelData.DrawBackground(null, lowToolStripMenuItem.Checked, highToolStripMenuItem.Checked, path1ToolStripMenuItem.Checked, path2ToolStripMenuItem.Checked);
						using (Bitmap res = bmp.ToBitmap(LevelImgPalette))
							res.Save(a.FileName);
					}
				}*/
		}

		private void transparentBackgroundToolStripMenuItem_CheckedChanged(object sender, EventArgs e)
		{
			Settings.TransparentBackgroundExport = transparentBackgroundToolStripMenuItem.Checked;
		}

		private void useHexadecimalIndexesToolStripMenuItem_CheckedChanged(object sender, EventArgs e)
		{
			Settings.UseHexadecimalIndexesExport = useHexadecimalIndexesToolStripMenuItem.Checked;
		}

		private void exportArtcollisionpriorityToolStripMenuItem_CheckedChanged(object sender, EventArgs e)
		{
			Settings.ExportArtCollisionPriority = exportArtcollisionpriorityToolStripMenuItem.Checked;
		}
		#endregion

		#region Help Menu
		private void viewReadmeToolStripMenuItem_Click(object sender, EventArgs e)
		{
			System.Diagnostics.Process.Start(Path.Combine(Path.GetDirectoryName(Application.ExecutablePath), "readme.txt"));
		}

		private void reportBugToolStripMenuItem_Click(object sender, EventArgs e)
		{
			using (BugReportDialog err = new BugReportDialog("SonLVL-RSDK", string.Join(Environment.NewLine, LogFile.ToArray())))
				err.ShowDialog();
		}
		#endregion
		#endregion

		void ObjectSelect_listView2_SelectedIndexChanged(object sender, EventArgs e)
		{
			if (!loaded) return;
			if (ObjectSelect.listView1.SelectedIndices.Count == 0) return;
			if (ObjectSelect.listView2.SelectedIndices.Count == 0) return;
			ObjectSelect.numericUpDown2.Value = (byte)ObjectSelect.listView2.SelectedItems[0].Tag;
		}

		void ObjectSelect_listView1_SelectedIndexChanged(object sender, EventArgs e)
		{
			if (!loaded) return;
			if (ObjectSelect.listView1.SelectedIndices.Count == 0) return;
			byte ID = (byte)ObjectSelect.listView1.SelectedItems[0].Tag;
			ObjectSelect.numericUpDown1.Value = ID;
			ObjectSelect.numericUpDown2.Value = LevelData.ObjTypes[ID].DefaultSubtype;
			ObjectSelect.listView2.Items.Clear();
			ObjectSelect.imageList2.Images.Clear();
			foreach (byte item in LevelData.ObjTypes[ID].Subtypes)
			{
				ObjectSelect.imageList2.Images.Add(LevelData.ObjTypes[ID].SubtypeImage(item).GetBitmap().ToBitmap(LevelData.BmpPal).Resize(ObjectSelect.imageList2.ImageSize));
				ObjectSelect.listView2.Items.Add(new ListViewItem(LevelData.ObjTypes[ID].SubtypeName(item), ObjectSelect.imageList2.Images.Count - 1) { Tag = item, Selected = item == LevelData.ObjTypes[ID].DefaultSubtype });
			}
		}

		void ObjectProperties_SelectedGridItemChanged(object sender, SelectedGridItemChangedEventArgs e)
		{
		}

		void ObjectProperties_PropertyValueChanged(object s, PropertyValueChangedEventArgs e)
		{
			foreach (Entry item in SelectedItems)
				item.UpdateSprite();
			DrawLevel();
		}

		void bgLayerDropDown_DropDownItemClicked(object sender, ToolStripItemClickedEventArgs e)
		{
			foreach (var item in bgLayerDropDown.DropDownItems.OfType<ToolStripMenuItem>())
				item.Checked = item == e.ClickedItem;
			bglayer = bgLayerDropDown.DropDownItems.IndexOf(e.ClickedItem);
			UpdateScrollBars();
			DrawLevel();
		}

		BitmapBits LevelImg8bpp;
		static readonly SolidBrush objectBrush = new SolidBrush(Color.FromArgb(128, Color.Cyan));
		static readonly Pen selectionPen = new Pen(Color.FromArgb(128, Color.Black)) { DashStyle = DashStyle.Dot };
		static readonly SolidBrush selectionBrush = new SolidBrush(Color.FromArgb(128, Color.White));
		internal void DrawLevel()
		{
			if (!loaded) return;
			ScrollingPanel panel;
			Rectangle selection;
			switch (CurrentTab)
			{
				case Tab.Objects:
					panel = objectPanel;
					selection = Rectangle.Empty;
					break;
				case Tab.Foreground:
					panel = foregroundPanel;
					selection = FGSelection;
					break;
				case Tab.Background:
					panel = backgroundPanel;
					selection = BGSelection;
					break;
				default:
					return;
			}
			Point camera = new Point(panel.HScrollValue, panel.VScrollValue);
			Size lvlsize = Size.Empty;
			ushort[][] layout = null;
			Rectangle dispRect = new Rectangle(camera.X, camera.Y, (int)(panel.PanelWidth / ZoomLevel), (int)(panel.PanelHeight / ZoomLevel));
			switch (CurrentTab)
			{
				case Tab.Objects:
				case Tab.Foreground:
					lvlsize = LevelData.FGSize;
					layout = LevelData.Scene.layout;
					LevelImg8bpp = LevelData.DrawForeground(dispRect, CurrentTab == Tab.Objects || includeobjectsWithFGToolStripMenuItem.Checked, objectsAboveHighPlaneToolStripMenuItem.Checked, lowToolStripMenuItem.Checked, highToolStripMenuItem.Checked, path1ToolStripMenuItem.Checked, path2ToolStripMenuItem.Checked);
					break;
				case Tab.Background:
					lvlsize = LevelData.BGSize[bglayer];
					layout = LevelData.Background.layers[bglayer].layout;
					LevelImg8bpp = LevelData.DrawBackground(bglayer, dispRect, lowToolStripMenuItem.Checked, highToolStripMenuItem.Checked, path1ToolStripMenuItem.Checked, path2ToolStripMenuItem.Checked);
					break;
			}
			switch (CurrentTab)
			{
				case Tab.Objects:
					if (enableGridToolStripMenuItem.Checked && ObjGrid > 0)
					{
						int gs = 1 << ObjGrid;
						for (int x = (gs - (camera.X % gs)) % gs; x < LevelImg8bpp.Width; x += gs)
							LevelImg8bpp.DrawLine(ColorGrid, x, 0, x, LevelImg8bpp.Height - 1);
						for (int y = (gs - (camera.Y % gs)) % gs; y < LevelImg8bpp.Height; y += gs)
							LevelImg8bpp.DrawLine(ColorGrid, 0, y, LevelImg8bpp.Width - 1, y);
					}
					break;
				case Tab.Foreground:
				case Tab.Background:
					if (enableGridToolStripMenuItem.Checked)
					{
						for (int x = (128 - (camera.X % 128)) % 128; x < LevelImg8bpp.Width; x += 128)
							LevelImg8bpp.DrawLine(ColorGrid, x, 0, x, LevelImg8bpp.Height - 1);
						for (int y = (128 - (camera.Y % 128)) % 128; y < LevelImg8bpp.Height; y += 128)
							LevelImg8bpp.DrawLine(ColorGrid, 0, y, LevelImg8bpp.Width - 1, y);
					}
					break;
			}
			if (anglesToolStripMenuItem.Checked && !noneToolStripMenuItem1.Checked)
				for (int y = Math.Max(camera.Y / 128, 0); y <= Math.Min((camera.Y + (panel.PanelHeight - 1) / ZoomLevel) / 128, lvlsize.Height - 1); y++)
					for (int x = Math.Max(camera.X / 128, 0); x <= Math.Min((camera.X + (panel.PanelWidth - 1) / ZoomLevel) / 128, lvlsize.Width - 1); x++)
						for (int b = 0; b < 8; b++)
							for (int a = 0; a < 8; a++)
								if (layout[y][x] < LevelData.NewChunks.chunkList.Length)
								{
									RSDKv3_4.Tiles128x128.Block.Tile blk = LevelData.NewChunks.chunkList[layout[y][x]].tiles[b][a];
									if (blk.tileIndex >= LevelData.NewTiles.Length) continue;
									RSDKv3_4.Tiles128x128.Block.Tile.Solidities solid = path2ToolStripMenuItem.Checked ? blk.solidityB : blk.solidityA;
									if (solid == RSDKv3_4.Tiles128x128.Block.Tile.Solidities.SolidNone) continue;
									byte angle = LevelData.Collision.collisionMasks[path2ToolStripMenuItem.Checked ? 1 : 0][blk.tileIndex].floorAngle;
									if (angle != 0xFF)
									{
										switch (blk.direction)
										{
											case RSDKv3_4.Tiles128x128.Block.Tile.Directions.FlipX:
												angle = (byte)(-angle & 0xFF);
												break;
											case RSDKv3_4.Tiles128x128.Block.Tile.Directions.FlipY:
												angle = (byte)((-(angle + 0x40) - 0x40) & 0xFF);
												break;
											case RSDKv3_4.Tiles128x128.Block.Tile.Directions.FlipXY:
												angle = (byte)((angle + 0x80) & 0xFF);
												break;
										}
									}
									DrawHUDNum(x * 128 + a * 16 - camera.X, y * 128 + b * 16 - camera.Y, angle.ToString("X2"));
								}
			if (hUDToolStripMenuItem.Checked)
			{
				Rectangle hudbnd = Rectangle.Empty;
				Rectangle tmpbnd;
				tmpbnd = hudbnd = DrawHUDStr(8, 8, "Screen Pos: ");
				hudbnd = Rectangle.Union(hudbnd, DrawHUDNum(tmpbnd.Right, tmpbnd.Top, camera.X.ToString("X4") + ' ' + camera.Y.ToString("X4")));
				tmpbnd = DrawHUDStr(hudbnd.Left, hudbnd.Bottom, "Level Size: ");
				hudbnd = Rectangle.Union(hudbnd, tmpbnd);
				hudbnd = Rectangle.Union(hudbnd, DrawHUDNum(tmpbnd.Right, tmpbnd.Top, (lvlsize.Width * 128).ToString("X4") + ' ' + (lvlsize.Height * 128).ToString("X4")));
				switch (CurrentTab)
				{
					case Tab.Objects:
					case Tab.Foreground:
						hudbnd = Rectangle.Union(hudbnd, DrawHUDStr(hudbnd.Left, hudbnd.Bottom, $"Objects: {LevelData.Objects.Count}"));
						break;
				}
				switch (CurrentTab)
				{
					case Tab.Foreground:
					case Tab.Background:
						tmpbnd = DrawHUDStr(hudbnd.Left, hudbnd.Bottom, "Chunk: ");
						hudbnd = Rectangle.Union(hudbnd, tmpbnd);
						hudbnd = Rectangle.Union(hudbnd, DrawHUDNum(tmpbnd.Right, tmpbnd.Top, SelectedChunk.ToString("X2")));
						break;
				}
				if (path1ToolStripMenuItem.Checked)
					hudbnd = Rectangle.Union(hudbnd, DrawHUDStr(hudbnd.Left, hudbnd.Bottom, "Path 1"));
				else if (path2ToolStripMenuItem.Checked)
					hudbnd = Rectangle.Union(hudbnd, DrawHUDStr(hudbnd.Left, hudbnd.Bottom, "Path 2"));
			}
			if (CurrentTab == Tab.Objects && dragdrop)
				LevelImg8bpp.DrawSprite(LevelData.GetObjectDefinition(dragobj).Image, dragpoint);
			LevelBmp = LevelImg8bpp.ToBitmap(LevelImgPalette).To32bpp();
			LevelGfx = Graphics.FromImage(LevelBmp);
			LevelGfx.SetOptions();
			Point pnlcur = panel.PanelPointToClient(Cursor.Position);
			switch (CurrentTab)
			{
				case Tab.Objects:
					foreach (Entry item in SelectedItems)
					{
						Rectangle bnd = item.Bounds;
						bnd.Offset(-camera.X, -camera.Y);
						LevelGfx.FillRectangle(objectBrush, bnd);
						bnd.Width--; bnd.Height--;
						LevelGfx.DrawRectangle(selectionPen, bnd);
					}
					if (selecting)
					{
						Rectangle selbnds = Rectangle.FromLTRB(
						Math.Min(selpoint.X, lastmouse.X) - camera.X,
						Math.Min(selpoint.Y, lastmouse.Y) - camera.Y,
						Math.Max(selpoint.X, lastmouse.X) - camera.X,
						Math.Max(selpoint.Y, lastmouse.Y) - camera.Y);
						LevelGfx.FillRectangle(selectionBrush, selbnds);
						selbnds.Width--; selbnds.Height--;
						LevelGfx.DrawRectangle(selectionPen, selbnds);
					}
					break;
				case Tab.Foreground:
				case Tab.Background:
					if (!selecting && SelectedChunk < LevelData.NewChunks.chunkList.Length)
						LevelGfx.DrawImage(LevelData.CompChunkBmps[SelectedChunk],
						new Rectangle(((((int)(pnlcur.X / ZoomLevel) + camera.X) / 128) * 128) - camera.X, ((((int)(pnlcur.Y / ZoomLevel) + camera.Y) / 128) * 128) - camera.Y, 128, 128),
						0, 0, 128, 128,
						GraphicsUnit.Pixel, imageTransparency);
					if (!selection.IsEmpty)
					{
						Rectangle selbnds = selection.Scale(128, 128);
						selbnds.Offset(-camera.X, -camera.Y);
						LevelGfx.FillRectangle(selectionBrush, selbnds);
						selbnds.Width--; selbnds.Height--;
						LevelGfx.DrawRectangle(selectionPen, selbnds);
					}
					break;
			}
			panel.PanelGraphics.DrawImage(LevelBmp, 0, 0, panel.PanelWidth, panel.PanelHeight);
		}

		public Rectangle DrawHUDStr(int x, int y, string str)
		{
			HUDImage curimg;
			int curX = x;
			int curY = y;
			Rectangle bounds = new Rectangle() { X = x, Y = y };
			int maxX = x;
			foreach (string line in str.Split(new char[] { '\n' }, StringSplitOptions.None))
			{
				int maxY = 0;
				foreach (char ch in line)
				{
					if (HUDLetters.ContainsKey(char.ToUpperInvariant(ch)))
						curimg = HUDLetters[char.ToUpperInvariant(ch)];
					else
						curimg = HUDLetters[' '];
					LevelImg8bpp.DrawSprite(curimg.Image, curX, curY);
					curX += curimg.Width;
					maxX = Math.Max(maxX, curX);
					maxY = Math.Max(maxY, curimg.Height);
				}
				curY += maxY;
				curX = x;
			}
			bounds.Width = maxX - x;
			bounds.Height = curY - y;
			return bounds;
		}

		public Rectangle DrawHUDNum(int x, int y, string str)
		{
			HUDImage curimg;
			int curX = x;
			int curY = y;
			Rectangle bounds = new Rectangle() { X = x, Y = y };
			int maxX = x;
			foreach (string line in str.Split(new char[] { '\n' }, StringSplitOptions.None))
			{
				int maxY = 0;
				foreach (char ch in line)
				{
					if (HUDNumbers.ContainsKey(char.ToUpperInvariant(ch)))
						curimg = HUDNumbers[char.ToUpperInvariant(ch)];
					else
						curimg = HUDNumbers[' '];
					LevelImg8bpp.DrawSprite(curimg.Image, curX, curY);
					curX += curimg.Width;
					maxX = Math.Max(maxX, curX);
					maxY = Math.Max(maxY, curimg.Height);
				}
				curY += maxY;
				curX = x;
			}
			bounds.Width = maxX - x;
			bounds.Height = curY - y;
			return bounds;
		}

		private void panel_Paint(object sender, PaintEventArgs e)
		{
			DrawLevel();
		}

		private void UpdateScrollBars()
		{
			objectPanel.HScrollMaximum = (int)Math.Max(((LevelData.FGWidth + 1) * 128) - (objectPanel.PanelWidth / ZoomLevel), 0);
			objectPanel.VScrollMaximum = (int)Math.Max(((LevelData.FGHeight + 1) * 128) - (objectPanel.PanelHeight / ZoomLevel), 0);
			foregroundPanel.HScrollMaximum = (int)Math.Max(((LevelData.FGWidth + 1) * 128) - (foregroundPanel.PanelWidth / ZoomLevel), 0);
			foregroundPanel.VScrollMaximum = (int)Math.Max(((LevelData.FGHeight + 1) * 128) - (foregroundPanel.PanelHeight / ZoomLevel), 0);
			backgroundPanel.HScrollMaximum = (int)Math.Max(((LevelData.BGWidth[bglayer] + 1) * 128) - (backgroundPanel.PanelWidth / ZoomLevel), 0);
			backgroundPanel.VScrollMaximum = (int)Math.Max(((LevelData.BGHeight[bglayer] + 1) * 128) - (backgroundPanel.PanelHeight / ZoomLevel), 0);
		}

		Rectangle prevbnds;
		FormWindowState prevstate;
		private void MainForm_KeyDown(object sender, KeyEventArgs e)
		{
			switch (e.KeyCode)
			{
				case Keys.Enter:
					if (e.Alt)
					{
						if (!TopMost)
						{
							prevbnds = Bounds;
							prevstate = WindowState;
							TopMost = true;
							WindowState = FormWindowState.Normal;
							FormBorderStyle = FormBorderStyle.None;
							Bounds = Screen.FromControl(this).Bounds;
						}
						else
						{
							TopMost = false;
							WindowState = prevstate;
							FormBorderStyle = FormBorderStyle.Sizable;
							Bounds = prevbnds;
						}
					}
					break;
				case Keys.F5:
					mainMenuStrip.ShowHide();
					break;
				case Keys.D1:
				case Keys.NumPad1:
					if (e.Control)
						CurrentTab = Tab.Objects;
					break;
				case Keys.D2:
				case Keys.NumPad2:
					if (e.Control)
						CurrentTab = Tab.Foreground;
					break;
				case Keys.D3:
				case Keys.NumPad3:
					if (e.Control)
						CurrentTab = Tab.Background;
					break;
				case Keys.D4:
				case Keys.NumPad4:
					if (e.Control)
						CurrentTab = Tab.Art;
					break;
			}
		}

		private void objectPanel_KeyDown(object sender, KeyEventArgs e)
		{
			long hstep = e.Control ? int.MaxValue : e.Shift ? 128 : 16;
			long vstep = e.Control ? int.MaxValue : e.Shift ? 128 : 16;
			switch (e.KeyCode)
			{
				case Keys.Up:
					if (!loaded) return;
					objectPanel.VScrollValue = (int)Math.Max(objectPanel.VScrollValue - vstep, objectPanel.VScrollMinimum);
					break;
				case Keys.Down:
					if (!loaded) return;
					objectPanel.VScrollValue = (int)Math.Min(objectPanel.VScrollValue + vstep, objectPanel.VScrollMaximum - 128 + 1);
					break;
				case Keys.Left:
					if (!loaded) return;
					objectPanel.HScrollValue = (int)Math.Max(objectPanel.HScrollValue - hstep, objectPanel.HScrollMinimum);
					break;
				case Keys.Right:
					if (!loaded) return;
					objectPanel.HScrollValue = (int)Math.Min(objectPanel.HScrollValue + hstep, objectPanel.HScrollMaximum - 128 + 1);
					break;
				case Keys.Delete:
					if (!loaded) return;
					if (SelectedItems.Count > 0)
						deleteToolStripMenuItem_Click(sender, EventArgs.Empty);
					break;
				case Keys.A:
					if (!loaded) return;
					for (int i = 0; i < SelectedItems.Count; i++)
					{
						if (SelectedItems[i] is ObjectEntry oi)
						{
							oi.ID = (byte)(oi.ID == 0 ? 255 : oi.ID - 1);
							SelectedItems[i].UpdateSprite();
						}
					}
					DrawLevel();
					break;
				case Keys.C:
					if (!loaded) return;
					if (e.Control)
						if (SelectedItems.Count > 0)
							copyToolStripMenuItem_Click(sender, EventArgs.Empty);
					break;
				case Keys.J:
					int gs = ObjGrid + 1;
					if (gs < objGridSizeDropDownButton.DropDownItems.Count)
						objGridSizeDropDownButton_DropDownItemClicked(this, new ToolStripItemClickedEventArgs(objGridSizeDropDownButton.DropDownItems[gs]));
					break;
				case Keys.M:
					if (ObjGrid > 0)
						objGridSizeDropDownButton_DropDownItemClicked(this, new ToolStripItemClickedEventArgs(objGridSizeDropDownButton.DropDownItems[ObjGrid - 1]));
					break;
				case Keys.S:
					if (!loaded) return;
					if (!e.Control)
					{
						foreach (ObjectEntry item in SelectedItems.OfType<ObjectEntry>())
						{
							unchecked
							{
								--item.SubType;
							}
							item.UpdateSprite();
						}
						DrawLevel();
					}
					break;
				case Keys.V:
					if (!loaded) return;
					if (e.Control)
					{
						menuLoc = new Point(objectPanel.PanelWidth / 2, objectPanel.PanelHeight / 2);
						pasteToolStripMenuItem_Click(sender, EventArgs.Empty);
					}
					break;
				case Keys.X:
					if (!loaded) return;
					if (e.Control)
					{
						if (SelectedItems.Count > 0)
							cutToolStripMenuItem_Click(sender, EventArgs.Empty);
					}
					else
					{
						foreach (ObjectEntry item in SelectedItems.OfType<ObjectEntry>())
						{
							++item.SubType;
							item.UpdateSprite();
						}
						DrawLevel();
					}
					break;
				case Keys.Z:
					if (!loaded) return;
					if (!e.Control)
					{
						for (int i = 0; i < SelectedItems.Count; i++)
						{
							if (SelectedItems[i] is ObjectEntry oi)
							{
								oi.ID = (byte)(oi.ID == 255 ? 0 : oi.ID + 1);
								SelectedItems[i].UpdateSprite();
							}
						}
						DrawLevel();
					}
					break;
				case Keys.NumPad1:
					if (!loaded || e.Control) return;
					gs = 1 << ObjGrid;
					foreach (Entry ent in SelectedItems)
					{
						ent.X -= (ushort)gs;
						ent.Y += (ushort)gs;
						ent.AdjustSpritePosition(-gs, gs);
					}
					DrawLevel();
					break;
				case Keys.NumPad2:
					if (!loaded || e.Control) return;
					gs = 1 << ObjGrid;
					foreach (Entry ent in SelectedItems)
					{
						ent.Y += (ushort)gs;
						ent.AdjustSpritePosition(0, gs);
					}
					DrawLevel();
					break;
				case Keys.NumPad3:
					if (!loaded || e.Control) return;
					gs = 1 << ObjGrid;
					foreach (Entry ent in SelectedItems)
					{
						ent.X += (ushort)gs;
						ent.Y += (ushort)gs;
						ent.AdjustSpritePosition(gs, gs);
					}
					DrawLevel();
					break;
				case Keys.NumPad4:
					if (!loaded || e.Control) return;
					gs = 1 << ObjGrid;
					foreach (Entry ent in SelectedItems)
					{
						ent.X -= (ushort)gs;
						ent.AdjustSpritePosition(-gs, 0);
					}
					DrawLevel();
					break;
				case Keys.NumPad6:
					if (!loaded) return;
					gs = 1 << ObjGrid;
					foreach (Entry ent in SelectedItems)
					{
						ent.X += (ushort)gs;
						ent.AdjustSpritePosition(gs, 0);
					}
					DrawLevel();
					break;
				case Keys.NumPad7:
					if (!loaded) return;
					gs = 1 << ObjGrid;
					foreach (Entry ent in SelectedItems)
					{
						ent.X -= (ushort)gs;
						ent.Y -= (ushort)gs;
						ent.AdjustSpritePosition(-gs, -gs);
					}
					DrawLevel();
					break;
				case Keys.NumPad8:
					if (!loaded) return;
					gs = 1 << ObjGrid;
					foreach (Entry ent in SelectedItems)
					{
						ent.Y -= (ushort)gs;
						ent.AdjustSpritePosition(0, -gs);
					}
					DrawLevel();
					break;
				case Keys.NumPad9:
					if (!loaded) return;
					gs = 1 << ObjGrid;
					foreach (Entry ent in SelectedItems)
					{
						ent.X += (ushort)gs;
						ent.Y -= (ushort)gs;
						ent.AdjustSpritePosition(gs, -gs);
					}
					DrawLevel();
					break;
			}
			panel_KeyDown(sender, e);
		}

		private void foregroundPanel_KeyDown(object sender, KeyEventArgs e)
		{
			long hstep = e.Control ? int.MaxValue : e.Shift ? 128 : 16;
			long vstep = e.Control ? int.MaxValue : e.Shift ? 128 : 16;
			switch (e.KeyCode)
			{
				case Keys.Up:
					if (!loaded) return;
					foregroundPanel.VScrollValue = (int)Math.Max(foregroundPanel.VScrollValue - vstep, foregroundPanel.VScrollMinimum);
					break;
				case Keys.Down:
					if (!loaded) return;
					foregroundPanel.VScrollValue = (int)Math.Min(foregroundPanel.VScrollValue + vstep, foregroundPanel.VScrollMaximum - 128 + 1);
					break;
				case Keys.Left:
					if (!loaded) return;
					foregroundPanel.HScrollValue = (int)Math.Max(foregroundPanel.HScrollValue - hstep, foregroundPanel.HScrollMinimum);
					break;
				case Keys.Right:
					if (!loaded) return;
					foregroundPanel.HScrollValue = (int)Math.Min(foregroundPanel.HScrollValue + hstep, foregroundPanel.HScrollMaximum - 128 + 1);
					break;
				case Keys.A:
					if (!loaded) return;
					SelectedChunk = (ushort)(SelectedChunk == 0 ? LevelData.NewChunks.chunkList.Length - 1 : SelectedChunk - 1);
					DrawLevel();
					break;
				case Keys.Z:
					if (!loaded) return;
					if (!e.Control)
					{
						SelectedChunk = (ushort)(SelectedChunk == LevelData.NewChunks.chunkList.Length - 1 ? 0 : SelectedChunk + 1);
						DrawLevel();
					}
					break;
			}
			panel_KeyDown(sender, e);
		}

		private void backgroundPanel_KeyDown(object sender, KeyEventArgs e)
		{
			long hstep = e.Control ? int.MaxValue : e.Shift ? 128 : 16;
			long vstep = e.Control ? int.MaxValue : e.Shift ? 128 : 16;
			switch (e.KeyCode)
			{
				case Keys.Up:
					if (!loaded) return;
					backgroundPanel.VScrollValue = (int)Math.Max(backgroundPanel.VScrollValue - vstep, backgroundPanel.VScrollMinimum);
					break;
				case Keys.Down:
					if (!loaded) return;
					backgroundPanel.VScrollValue = (int)Math.Min(backgroundPanel.VScrollValue + vstep, backgroundPanel.VScrollMaximum - 128 + 1);
					break;
				case Keys.Left:
					if (!loaded) return;
					backgroundPanel.HScrollValue = (int)Math.Max(backgroundPanel.HScrollValue - hstep, backgroundPanel.HScrollMinimum);
					break;
				case Keys.Right:
					if (!loaded) return;
					backgroundPanel.HScrollValue = (int)Math.Min(backgroundPanel.HScrollValue + hstep, backgroundPanel.HScrollMaximum - 128 + 1);
					break;
				case Keys.A:
					if (!loaded) return;
					SelectedChunk = (ushort)(SelectedChunk == 0 ? LevelData.NewChunks.chunkList.Length - 1 : SelectedChunk - 1);
					DrawLevel();
					break;
				case Keys.Z:
					if (!loaded) return;
					if (!e.Control)
					{
						SelectedChunk = (ushort)(SelectedChunk == LevelData.NewChunks.chunkList.Length - 1 ? 0 : SelectedChunk + 1);
						DrawLevel();
					}
					break;
			}
			panel_KeyDown(sender, e);
		}

		private void panel_KeyDown(object sender, KeyEventArgs e)
		{
			switch (e.KeyCode)
			{
				case Keys.Q:
					bool angles = anglesToolStripMenuItem.Checked;
					foreach (ToolStripItem item in collisionToolStripMenuItem.DropDownItems)
						if (item is ToolStripMenuItem item1)
							item1.Checked = false;
					noneToolStripMenuItem1.Checked = true;
					anglesToolStripMenuItem.Checked = angles;
					DrawLevel();
					break;
				case Keys.W:
					angles = anglesToolStripMenuItem.Checked;
					foreach (ToolStripItem item in collisionToolStripMenuItem.DropDownItems)
						if (item is ToolStripMenuItem item1)
							item1.Checked = false;
					path1ToolStripMenuItem.Checked = true;
					anglesToolStripMenuItem.Checked = angles;
					DrawLevel();
					break;
				case Keys.E:
					angles = anglesToolStripMenuItem.Checked;
					foreach (ToolStripItem item in collisionToolStripMenuItem.DropDownItems)
						if (item is ToolStripMenuItem item1)
							item1.Checked = false;
					path2ToolStripMenuItem.Checked = true;
					anglesToolStripMenuItem.Checked = angles;
					DrawLevel();
					break;
				case Keys.R:
					if (!(e.Alt & e.Control))
					{
						anglesToolStripMenuItem.Checked = !anglesToolStripMenuItem.Checked;
						DrawLevel();
					}
					break;
				case Keys.T:
					objectsAboveHighPlaneToolStripMenuItem.Checked = !objectsAboveHighPlaneToolStripMenuItem.Checked;
					DrawLevel();
					break;
				case Keys.Y:
					if (!e.Control)
					{
						lowToolStripMenuItem.Checked = !lowToolStripMenuItem.Checked;
						DrawLevel();
					}
					break;
				case Keys.U:
					highToolStripMenuItem.Checked = !highToolStripMenuItem.Checked;
					DrawLevel();
					break;
				case Keys.I:
					enableGridToolStripMenuItem.Checked = !enableGridToolStripMenuItem.Checked;
					DrawLevel();
					break;
				case Keys.O:
					if (!e.Control)
					{
						hUDToolStripMenuItem.Checked = !hUDToolStripMenuItem.Checked;
						DrawLevel();
					}
					break;
				case Keys.OemMinus:
				case Keys.Subtract:
					for (int i = 1; i < zoomToolStripMenuItem.DropDownItems.Count; i++)
						if (((ToolStripMenuItem)zoomToolStripMenuItem.DropDownItems[i]).Checked)
						{
							zoomToolStripMenuItem_DropDownItemClicked(sender, new ToolStripItemClickedEventArgs(zoomToolStripMenuItem.DropDownItems[i - 1]));
							break;
						}
					break;
				case Keys.Oemplus:
				case Keys.Add:
					for (int i = 0; i < zoomToolStripMenuItem.DropDownItems.Count - 1; i++)
						if (((ToolStripMenuItem)zoomToolStripMenuItem.DropDownItems[i]).Checked)
						{
							zoomToolStripMenuItem_DropDownItemClicked(sender, new ToolStripItemClickedEventArgs(zoomToolStripMenuItem.DropDownItems[i + 1]));
							break;
						}
					break;
			}
		}

		private Entry GetEntryAtPoint(Point point)
		{
			foreach (ObjectEntry item in LevelData.Objects.Reverse<ObjectEntry>())
				if (item.Bounds.Contains(point))
					return item;
			return null;
		}

		private void objectPanel_MouseDown(object sender, MouseEventArgs e)
		{
			if (!loaded) return;
			double gs = 1 << ObjGrid;
			int curx = (int)(e.X / ZoomLevel) + objectPanel.HScrollValue;
			int cury = (int)(e.Y / ZoomLevel) + objectPanel.VScrollValue;
			ushort gridx = (ushort)(Math.Round(curx / gs, MidpointRounding.AwayFromZero) * gs);
			ushort gridy = (ushort)(Math.Round(cury / gs, MidpointRounding.AwayFromZero) * gs);
			switch (e.Button)
			{
				case MouseButtons.Left:
					if (e.Clicks == 2)
					{
						if (ObjectSelect.ShowDialog(this) == DialogResult.OK)
						{
							ObjectEntry ent = LevelData.CreateObject((byte)ObjectSelect.numericUpDown1.Value);
							ent.SubType = (byte)ObjectSelect.numericUpDown2.Value;
							ent.X = gridx;
							ent.Y = gridy;
							ent.UpdateSprite();
							SelectedItems.Clear();
							SelectedItems.Add(ent);
							SelectedObjectChanged();
							DrawLevel();
						}
					}
					Entry entry = GetEntryAtPoint(new Point(curx, cury));
					if (entry == null)
					{
						objdrag = false;
						selecting = true;
						selpoint = new Point(curx, cury);
						SelectedItems.Clear();
						SelectedObjectChanged();
					}
					else
					{
						if (ModifierKeys == Keys.Control)
						{
							if (SelectedItems.Contains(entry))
								SelectedItems.Remove(entry);
							else
								SelectedItems.Add(entry);
						}
						else if (!SelectedItems.Contains(entry))
						{
							SelectedItems.Clear();
							SelectedItems.Add(entry);
						}
						SelectedObjectChanged();
						objdrag = true;
						DrawLevel();
					}
					break;
				case MouseButtons.Right:
					menuLoc = e.Location;
					entry = GetEntryAtPoint(new Point(curx, cury));
					if (entry != null)
					{
						if (!SelectedItems.Contains(entry))
						{
							SelectedItems.Clear();
							SelectedItems.Add(entry);
						}
						SelectedObjectChanged();
						DrawLevel();
					}
					objdrag = false;
					if (SelectedItems.Count > 0)
					{
						cutToolStripMenuItem.Enabled = true;
						copyToolStripMenuItem.Enabled = true;
						deleteToolStripMenuItem.Enabled = true;
					}
					else
					{
						cutToolStripMenuItem.Enabled = false;
						copyToolStripMenuItem.Enabled = false;
						deleteToolStripMenuItem.Enabled = false;
					}
					pasteToolStripMenuItem.Enabled = Clipboard.ContainsData(typeof(List<Entry>).AssemblyQualifiedName);
					objectContextMenuStrip.Show(objectPanel, menuLoc);
					break;
			}
		}

		private void objectPanel_MouseMove(object sender, MouseEventArgs e)
		{
			if (!loaded) return;
			if (e.X < 0 || e.Y < 0 || e.X > objectPanel.PanelWidth || e.Y > objectPanel.PanelHeight) return;
			Point mouse = new Point((int)(e.X / ZoomLevel) + objectPanel.HScrollValue, (int)(e.Y / ZoomLevel) + objectPanel.VScrollValue);
			bool redraw = false;
			switch (e.Button)
			{
				case MouseButtons.Left:
					if (objdrag)
					{
						int difX = mouse.X - lastmouse.X;
						int difY = mouse.Y - lastmouse.Y;
						foreach (Entry item in SelectedItems)
						{
							item.X = (ushort)(item.X + difX);
							item.Y = (ushort)(item.Y + difY);
							item.AdjustSpritePosition(difX, difY);
						}
						redraw = true;
					}
					else if (selecting)
					{
						int selobjs = SelectedItems.Count;
						SelectedItems.Clear();
						Rectangle selbnds = Rectangle.FromLTRB(
						Math.Min(selpoint.X, mouse.X),
						Math.Min(selpoint.Y, mouse.Y),
						Math.Max(selpoint.X, mouse.X),
						Math.Max(selpoint.Y, mouse.Y));
						foreach (ObjectEntry item in LevelData.Objects)
							if (item.Bounds.IntersectsWith(selbnds))
								SelectedItems.Add(item);
						if (selobjs != SelectedItems.Count) SelectedObjectChanged();
						redraw = true;
					}
					break;
			}
			objectPanel.PanelCursor = GetEntryAtPoint(mouse) == null ? Cursors.Default : Cursors.SizeAll;
			if (redraw) DrawLevel();
			lastmouse = mouse;
		}

		private void objectPanel_MouseUp(object sender, MouseEventArgs e)
		{
			if (objdrag)
			{
				if (ObjGrid > 0)
				{
					double gs = 1 << ObjGrid;
					foreach (Entry item in SelectedItems)
					{
						item.X = (ushort)(Math.Round(item.X / gs, MidpointRounding.AwayFromZero) * gs);
						item.Y = (ushort)(Math.Round(item.Y / gs, MidpointRounding.AwayFromZero) * gs);
						item.UpdateSprite();
					}
				}
				else
					foreach (Entry item in SelectedItems)
						item.UpdateSprite();
				ObjectProperties.SelectedObjects = SelectedItems.ToArray();
				LevelData.Objects.Sort();
			}
			objdrag = false;
			selecting = false;
			DrawLevel();
		}

		private void foregroundPanel_MouseDown(object sender, MouseEventArgs e)
		{
			if (!loaded) return;
			Point chunkpoint = new Point(((int)(e.X / ZoomLevel) + foregroundPanel.HScrollValue) / 128, ((int)(e.Y / ZoomLevel) + foregroundPanel.VScrollValue) / 128);
			if (chunkpoint.X >= LevelData.FGWidth | chunkpoint.Y >= LevelData.FGHeight) return;
			switch (e.Button)
			{
				case MouseButtons.Left:
					FGSelection = Rectangle.Empty;
					LevelData.Scene.layout[chunkpoint.Y][chunkpoint.X] = SelectedChunk;
					DrawLevel();
					break;
				case MouseButtons.Right:
					menuLoc = chunkpoint;
					if (!FGSelection.Contains(chunkpoint))
					{
						FGSelection = Rectangle.Empty;
						DrawLevel();
					}
					lastmouse = new Point((int)(e.X / ZoomLevel) + foregroundPanel.HScrollValue, (int)(e.Y / ZoomLevel) + foregroundPanel.VScrollValue);
					break;
			}
		}

		private void foregroundPanel_MouseMove(object sender, MouseEventArgs e)
		{
			if (!loaded) return;
			if (e.X < 0 || e.Y < 0 || e.X > foregroundPanel.PanelWidth || e.Y > foregroundPanel.PanelHeight) return;
			Point mouse = new Point((int)(e.X / ZoomLevel) + foregroundPanel.HScrollValue, (int)(e.Y / ZoomLevel) + foregroundPanel.VScrollValue);
			Point chunkpoint = new Point(mouse.X / 128, mouse.Y / 128);
			if (chunkpoint.X >= LevelData.FGWidth | chunkpoint.Y >= LevelData.FGHeight) return;
			switch (e.Button)
			{
				case MouseButtons.Left:
					if (LevelData.Scene.layout[chunkpoint.Y][chunkpoint.X] != SelectedChunk)
					{
						LevelData.Scene.layout[chunkpoint.Y][chunkpoint.X] = SelectedChunk;
						DrawLevel();
					}
					break;
				case MouseButtons.Right:
					if (!selecting)
						if (Math.Sqrt(Math.Pow(e.X - lastmouse.X, 2) + Math.Pow(e.Y - lastmouse.Y, 2)) > 5)
							selecting = true;
						else
							break;
					if (FGSelection.IsEmpty)
						FGSelection = new Rectangle(chunkpoint, new Size(1, 1));
					else
					{
						int l = Math.Min(FGSelection.Left, chunkpoint.X);
						int t = Math.Min(FGSelection.Top, chunkpoint.Y);
						int r = Math.Max(FGSelection.Right, chunkpoint.X + 1);
						int b = Math.Max(FGSelection.Bottom, chunkpoint.Y + 1);
						if (FGSelection.Width > 1 && lastchunkpoint.X == l && chunkpoint.X > lastchunkpoint.X)
							l = chunkpoint.X;
						if (FGSelection.Height > 1 && lastchunkpoint.Y == t && chunkpoint.Y > lastchunkpoint.Y)
							t = chunkpoint.Y;
						if (FGSelection.Width > 1 && lastchunkpoint.X == r - 1 && chunkpoint.X < lastchunkpoint.X)
							r = chunkpoint.X + 1;
						if (FGSelection.Height > 1 && lastchunkpoint.Y == b - 1 && chunkpoint.Y < lastchunkpoint.Y)
							b = chunkpoint.Y + 1;
						FGSelection = Rectangle.FromLTRB(l, t, r, b);
					}
					DrawLevel();
					break;
				default:
					if (chunkpoint != lastchunkpoint)
						DrawLevel();
					break;
			}
			lastchunkpoint = chunkpoint;
		}

		private void foregroundPanel_MouseUp(object sender, MouseEventArgs e)
		{
			switch (e.Button)
			{
				case MouseButtons.Left:
					DrawLevel();
					break;
				case MouseButtons.Right:
					Point mouse = new Point((int)(e.X / ZoomLevel) + foregroundPanel.HScrollValue, (int)(e.Y / ZoomLevel) + foregroundPanel.VScrollValue);
					Point chunkpoint = new Point(mouse.X / 128, mouse.Y / 128);
					if (chunkpoint.X < 0 || chunkpoint.Y < 0 || chunkpoint.X >= LevelData.FGWidth || chunkpoint.Y >= LevelData.FGHeight) return;
					if (FGSelection.IsEmpty)
					{
						SelectedChunk = LevelData.Scene.layout[chunkpoint.Y][chunkpoint.X];
						if (SelectedChunk < LevelData.NewChunks.chunkList.Length)
							ChunkSelector.SelectedIndex = SelectedChunk;
						DrawLevel();
					}
					else if (!selecting)
					{
						pasteOnceToolStripMenuItem.Enabled = pasteRepeatingToolStripMenuItem.Enabled = Clipboard.ContainsData(typeof(LayoutSection).AssemblyQualifiedName);
						pasteSectionOnceToolStripMenuItem.Enabled = pasteSectionRepeatingToolStripMenuItem.Enabled = layoutSectionListBox.SelectedIndex != -1;
						layoutContextMenuStrip.Show(foregroundPanel, e.Location);
					}
					selecting = false;
					break;
			}
		}

		private void backgroundPanel_MouseDown(object sender, MouseEventArgs e)
		{
			if (!loaded) return;
			Point chunkpoint = new Point(((int)(e.X / ZoomLevel) + backgroundPanel.HScrollValue) / 128, ((int)(e.Y / ZoomLevel) + backgroundPanel.VScrollValue) / 128);
			if (chunkpoint.X >= LevelData.BGWidth[bglayer] | chunkpoint.Y >= LevelData.BGHeight[bglayer]) return;
			switch (e.Button)
			{
				case MouseButtons.Left:
					BGSelection = Rectangle.Empty;
					LevelData.Background.layers[bglayer].layout[chunkpoint.Y][chunkpoint.X] = SelectedChunk;
					DrawLevel();
					break;
				case MouseButtons.Right:
					menuLoc = chunkpoint;
					if (!BGSelection.Contains(chunkpoint))
					{
						BGSelection = Rectangle.Empty;
						DrawLevel();
					}
					lastmouse = new Point((int)(e.X / ZoomLevel) + foregroundPanel.HScrollValue, (int)(e.Y / ZoomLevel) + foregroundPanel.VScrollValue);
					break;
			}
		}

		private void backgroundPanel_MouseMove(object sender, MouseEventArgs e)
		{
			if (!loaded) return;
			if (e.X < 0 || e.Y < 0 || e.X > backgroundPanel.PanelWidth || e.Y > backgroundPanel.PanelHeight) return;
			Point mouse = new Point((int)(e.X / ZoomLevel) + backgroundPanel.HScrollValue, (int)(e.Y / ZoomLevel) + backgroundPanel.VScrollValue);
			Point chunkpoint = new Point(mouse.X / 128, mouse.Y / 128);
			if (chunkpoint.X >= LevelData.BGWidth[bglayer] | chunkpoint.Y >= LevelData.BGHeight[bglayer]) return;
			switch (e.Button)
			{
				case MouseButtons.Left:
					if (LevelData.Background.layers[bglayer].layout[chunkpoint.Y][chunkpoint.X] != SelectedChunk)
					{
						LevelData.Background.layers[bglayer].layout[chunkpoint.Y][chunkpoint.X] = SelectedChunk;
						DrawLevel();
					}
					break;
				case MouseButtons.Right:
					if (!selecting)
						if (Math.Sqrt(Math.Pow(e.X - lastmouse.X, 2) + Math.Pow(e.Y - lastmouse.Y, 2)) > 5)
							selecting = true;
						else
							break;
					if (BGSelection.IsEmpty)
						BGSelection = new Rectangle(chunkpoint, new Size(1, 1));
					else
					{
						int l = Math.Min(BGSelection.Left, chunkpoint.X);
						int t = Math.Min(BGSelection.Top, chunkpoint.Y);
						int r = Math.Max(BGSelection.Right, chunkpoint.X + 1);
						int b = Math.Max(BGSelection.Bottom, chunkpoint.Y + 1);
						if (BGSelection.Width > 1 && lastchunkpoint.X == l && chunkpoint.X > lastchunkpoint.X)
							l = chunkpoint.X;
						if (BGSelection.Height > 1 && lastchunkpoint.Y == t && chunkpoint.Y > lastchunkpoint.Y)
							t = chunkpoint.Y;
						if (BGSelection.Width > 1 && lastchunkpoint.X == r - 1 && chunkpoint.X < lastchunkpoint.X)
							r = chunkpoint.X + 1;
						if (BGSelection.Height > 1 && lastchunkpoint.Y == b - 1 && chunkpoint.Y < lastchunkpoint.Y)
							b = chunkpoint.Y + 1;
						BGSelection = Rectangle.FromLTRB(l, t, r, b);
					}
					DrawLevel();
					break;
				default:
					if (chunkpoint != lastchunkpoint)
						DrawLevel();
					break;
			}
			lastchunkpoint = chunkpoint;
		}

		private void backgroundPanel_MouseUp(object sender, MouseEventArgs e)
		{
			switch (e.Button)
			{
				case MouseButtons.Left:
					DrawLevel();
					break;
				case MouseButtons.Right:
					Point mouse = new Point((int)(e.X / ZoomLevel) + backgroundPanel.HScrollValue, (int)(e.Y / ZoomLevel) + backgroundPanel.VScrollValue);
					Point chunkpoint = new Point(mouse.X / 128, mouse.Y / 128);
					if (chunkpoint.X < 0 || chunkpoint.Y < 0 || chunkpoint.X >= LevelData.BGWidth[bglayer] || chunkpoint.Y >= LevelData.BGHeight[bglayer]) return;
					if (BGSelection.IsEmpty)
					{
						SelectedChunk = LevelData.Background.layers[bglayer].layout[chunkpoint.Y][chunkpoint.X];
						if (SelectedChunk < LevelData.NewChunks.chunkList.Length)
							ChunkSelector.SelectedIndex = SelectedChunk;
						DrawLevel();
					}
					else if (!selecting)
					{
						pasteOnceToolStripMenuItem.Enabled = pasteRepeatingToolStripMenuItem.Enabled = Clipboard.ContainsData(typeof(LayoutSection).AssemblyQualifiedName);
						pasteSectionOnceToolStripMenuItem.Enabled = pasteSectionRepeatingToolStripMenuItem.Enabled = layoutSectionListBox.SelectedIndex != -1;
						layoutContextMenuStrip.Show(backgroundPanel, e.Location);
					}
					selecting = false;
					break;
			}
		}

		private void ChunkSelector_SelectedIndexChanged(object sender, EventArgs e)
		{
			if (ChunkSelector.SelectedIndex == -1 || ChunkSelector.SelectedIndex >= LevelData.NewChunks.chunkList.Length) return;
			importChunksToolStripButton.Enabled = LevelData.HasFreeChunks();
			drawChunkToolStripButton.Enabled = importChunksToolStripButton.Enabled;
			SelectedChunk = (ushort)ChunkSelector.SelectedIndex;
			SelectedChunkBlock = new Rectangle(0, 0, 1, 1);
			chunkBlockEditor.SelectedObjects = new[] { LevelData.NewChunks.chunkList[SelectedChunk].tiles[0][0] };
			DrawChunkPicture();
			ChunkID.Value = SelectedChunk;
			ChunkCount.Text = LevelData.NewChunks.chunkList.Length.ToString("X");
			DrawLevel();
		}

		private void SelectedObjectChanged()
		{
			ObjectProperties.SelectedObjects = SelectedItems.ToArray();
			alignLeftWallToolStripButton.Enabled = alignRightWallToolStripButton.Enabled = alignGroundToolStripButton.Enabled =
				alignCeilingToolStripButton.Enabled = SelectedItems.Count > 0;
			alignBottomsToolStripButton.Enabled = alignCentersToolStripButton.Enabled = alignLeftsToolStripButton.Enabled =
				alignMiddlesToolStripButton.Enabled = alignRightsToolStripButton.Enabled = alignTopsToolStripButton.Enabled =
				SelectedItems.Count > 1;
		}

		private void ScrollBar_ValueChanged(object sender, EventArgs e)
		{
			if (!loaded) return;
			loaded = false;
			switch (CurrentTab)
			{
				case Tab.Objects:
					foregroundPanel.HScrollValue = Math.Min(objectPanel.HScrollValue, foregroundPanel.HScrollMaximum);
					foregroundPanel.VScrollValue = Math.Min(objectPanel.VScrollValue, foregroundPanel.VScrollMaximum);
					break;
				case Tab.Foreground:
					objectPanel.HScrollValue = Math.Min(foregroundPanel.HScrollValue, objectPanel.HScrollMaximum);
					objectPanel.VScrollValue = Math.Min(foregroundPanel.VScrollValue, objectPanel.VScrollMaximum);
					break;
			}
			loaded = true;
			DrawLevel();
		}

		private void panel_Resize(object sender, EventArgs e)
		{
			if (!loaded) return;
			loaded = false;
			UpdateScrollBars();
			loaded = true;
			DrawLevel();
		}

		Point menuLoc;
		private void addObjectToolStripMenuItem_Click(object sender, EventArgs e)
		{
			if (ObjectSelect.ShowDialog(this) == DialogResult.OK)
			{
				ObjectEntry ent = LevelData.CreateObject((byte)ObjectSelect.numericUpDown1.Value);
				ent.SubType = (byte)ObjectSelect.numericUpDown2.Value;
				double gs = 1 << ObjGrid;
				ent.X = (ushort)(Math.Round((menuLoc.X / ZoomLevel + objectPanel.HScrollValue) / gs, MidpointRounding.AwayFromZero) * gs);
				ent.Y = (ushort)(Math.Round((menuLoc.Y / ZoomLevel + objectPanel.VScrollValue) / gs, MidpointRounding.AwayFromZero) * gs);
				ent.UpdateSprite();
				SelectedItems.Clear();
				SelectedItems.Add(ent);
				SelectedObjectChanged();
				LevelData.Objects.Sort();
				DrawLevel();
			}
		}

		private void addGroupOfObjectsToolStripMenuItem_Click(object sender, EventArgs e)
		{
			if (ObjectSelect.ShowDialog(this) == DialogResult.OK)
			{
				byte ID = (byte)ObjectSelect.numericUpDown1.Value;
				byte sub = (byte)ObjectSelect.numericUpDown2.Value;
				using (AddGroupDialog dlg = new AddGroupDialog())
				{
					dlg.Text = "Add Group of Objects";
					if (dlg.ShowDialog(this) == DialogResult.OK)
					{
						double gs = 1 << ObjGrid;
						Point pt = new Point(
							(ushort)(Math.Round((menuLoc.X / ZoomLevel + objectPanel.HScrollValue) / gs, MidpointRounding.AwayFromZero) * gs),
							(ushort)(Math.Round((menuLoc.Y / ZoomLevel + objectPanel.VScrollValue) / gs, MidpointRounding.AwayFromZero) * gs)
							);
						int xst = pt.X;
						Size xsz = new Size((int)dlg.XDist.Value, 0);
						Size ysz = new Size(0, (int)dlg.YDist.Value);
						SelectedItems.Clear();
						for (int y = 0; y < dlg.Rows.Value; y++)
						{
							for (int x = 0; x < dlg.Columns.Value; x++)
							{
								ObjectEntry ent = LevelData.CreateObject(ID);
								ent.SubType = sub;
								ent.X = (ushort)(pt.X);
								ent.Y = (ushort)(pt.Y);
								ent.UpdateSprite();
								SelectedItems.Add(ent);
								pt += xsz;
							}
							pt.X = xst;
							pt += ysz;
						}
						SelectedObjectChanged();
						LevelData.Objects.Sort();
						DrawLevel();
					}
				}
			}
		}

		private void cutToolStripMenuItem_Click(object sender, EventArgs e)
		{
			List<Entry> selitems = new List<Entry>();
			foreach (Entry item in SelectedItems)
			{
				if (item is ObjectEntry oe)
				{
					LevelData.DeleteObject(oe);
					selitems.Add(item);
				}
			}
			if (selitems.Count == 0) return;
			Clipboard.SetData(typeof(List<Entry>).AssemblyQualifiedName, selitems);
			SelectedItems.Clear();
			SelectedObjectChanged();
			DrawLevel();
		}

		private void copyToolStripMenuItem_Click(object sender, EventArgs e)
		{
			List<Entry> selitems = new List<Entry>();
			foreach (Entry item in SelectedItems)
			{
				if (item is ObjectEntry)
					selitems.Add(item);
			}
			if (selitems.Count == 0) return;
			Clipboard.SetData(typeof(List<Entry>).AssemblyQualifiedName, selitems);
		}

		private void pasteToolStripMenuItem_Click(object sender, EventArgs e)
		{
			if (Clipboard.ContainsData(typeof(List<Entry>).AssemblyQualifiedName))
			{
				List<Entry> objs = Clipboard.GetData(typeof(List<Entry>).AssemblyQualifiedName) as List<Entry>;
				Point upleft = new Point(int.MaxValue, int.MaxValue);
				foreach (Entry item in objs)
				{
					upleft.X = Math.Min(upleft.X, item.X);
					upleft.Y = Math.Min(upleft.Y, item.Y);
				}
				Size off = new Size(((int)(menuLoc.X / ZoomLevel) + objectPanel.HScrollValue) - upleft.X, ((int)(menuLoc.Y / ZoomLevel) + objectPanel.VScrollValue) - upleft.Y);
				SelectedItems = new List<Entry>(objs);
				double gs = 1 << ObjGrid;
				foreach (Entry item in objs)
				{
					item.X += (ushort)off.Width;
					item.Y += (ushort)off.Height;
					item.X = (ushort)(Math.Round(item.X / gs, MidpointRounding.AwayFromZero) * gs);
					item.Y = (ushort)(Math.Round(item.Y / gs, MidpointRounding.AwayFromZero) * gs);
					item.ResetPos();
					if (item is ObjectEntry oe)
					{
						LevelData.Scene.entities.Add(oe.Entity);
						LevelData.Objects.Add(oe);
					}
					item.UpdateSprite();
				}
				SelectedObjectChanged();
				LevelData.Objects.Sort();
				DrawLevel();
			}
		}

		private void deleteToolStripMenuItem_Click(object sender, EventArgs e)
		{
			List<Entry> selitems = new List<Entry>();
			foreach (Entry item in SelectedItems)
			{
				if (item is ObjectEntry)
				{
					LevelData.DeleteObject((ObjectEntry)item);
					selitems.Add(item);
				}
			}
			if (selitems.Count == 0) return;
			SelectedItems.Clear();
			SelectedObjectChanged();
			DrawLevel();
		}

		private void tabControl1_SelectedIndexChanged(object sender, EventArgs e)
		{
			selecting = false;
			switch (CurrentTab)
			{
				case Tab.Objects:
					findToolStripMenuItem.Enabled = true;
					findNextToolStripMenuItem.Enabled = findPreviousToolStripMenuItem.Enabled = foundobjs == null;
					objectPanel.Focus();
					break;
				case Tab.Foreground:
					findToolStripMenuItem.Enabled = true;
					findNextToolStripMenuItem.Enabled = findPreviousToolStripMenuItem.Enabled = lastfoundfgchunk.HasValue;
					tabPage8.Controls.Add(ChunkSelector);
					tabPage9.Controls.Add(layoutSectionSplitContainer);
					ChunkSelector.AllowDrop = false;
					foregroundPanel.Focus();
					break;
				case Tab.Background:
					findToolStripMenuItem.Enabled = true;
					findNextToolStripMenuItem.Enabled = findPreviousToolStripMenuItem.Enabled = lastfoundbgchunk.HasValue;
					tabPage10.Controls.Add(ChunkSelector);
					tabPage11.Controls.Add(layoutSectionSplitContainer);
					ChunkSelector.AllowDrop = false;
					backgroundPanel.Focus();
					break;
				case Tab.Art:
					findToolStripMenuItem.Enabled = findNextToolStripMenuItem.Enabled = findPreviousToolStripMenuItem.Enabled = false;
					panel10.Controls.Add(ChunkSelector);
					ChunkSelector.AllowDrop = true;
					break;
				default:
					findToolStripMenuItem.Enabled = findNextToolStripMenuItem.Enabled = findPreviousToolStripMenuItem.Enabled = false;
					break;
			}
			DrawLevel();
		}

		int SelectedTile;
		Rectangle SelectedChunkBlock;
		Point SelectedColor;
		RSDKv3_4.Tiles128x128.Block.Tile copiedChunkBlock;

		private RSDKv3_4.Tiles128x128.Block.Tile[] GetSelectedChunkBlocks()
		{
			RSDKv3_4.Tiles128x128.Block.Tile[] blocks = new RSDKv3_4.Tiles128x128.Block.Tile[SelectedChunkBlock.Width * SelectedChunkBlock.Height];
			int i = 0;
			for (int y = SelectedChunkBlock.Top; y < SelectedChunkBlock.Bottom; y++)
				for (int x = SelectedChunkBlock.Left; x < SelectedChunkBlock.Right; x++)
					blocks[i++] = LevelData.NewChunks.chunkList[SelectedChunk].tiles[y][x];
			return blocks;
		}

		private void ChunkPicture_MouseDown(object sender, MouseEventArgs e)
		{
			if (!loaded) return;
			if (e.Button == chunkblockMouseDraw)
				ChunkPicture_MouseMove(sender, e);
			else if (e.Button == chunkblockMouseSelect)
			{
				if (!SelectedChunkBlock.Contains(e.X / 16, e.Y / 16))
				{
					SelectedChunkBlock = new Rectangle(e.X / 16, e.Y / 16, 1, 1);
					copiedChunkBlock = LevelData.NewChunks.chunkList[SelectedChunk].tiles[SelectedChunkBlock.Y][SelectedChunkBlock.X];
					if (copiedChunkBlock.tileIndex < LevelData.NewTiles.Length)
						TileSelector.SelectedIndex = copiedChunkBlock.tileIndex;
					chunkBlockEditor.SelectedObjects = new[] { copiedChunkBlock };
					DrawChunkPicture();
					selecting = true; // don't show the context menu when starting a new selection
				}
				else
					lastmouse = e.Location;
			}
		}

		private void ChunkPicture_MouseMove(object sender, MouseEventArgs e)
		{
			if (!loaded) return;
			if (e.X > 0 && e.Y > 0 && e.X < 128 && e.Y < 128)
				if (e.Button == chunkblockMouseDraw)
				{
					SelectedChunkBlock = new Rectangle(e.X / 16, e.Y / 16, 1, 1);
					RSDKv3_4.Tiles128x128.Block.Tile destBlock = LevelData.NewChunks.chunkList[SelectedChunk].tiles[SelectedChunkBlock.Y][SelectedChunkBlock.X];
					destBlock.tileIndex = copiedChunkBlock.tileIndex;
					destBlock.solidityA = copiedChunkBlock.solidityA;
					destBlock.solidityB = copiedChunkBlock.solidityB;
					destBlock.direction = copiedChunkBlock.direction;
					destBlock.visualPlane = copiedChunkBlock.visualPlane;
					chunkBlockEditor.SelectedObjects = new[] { destBlock };
					LevelData.RedrawChunk(SelectedChunk);
					DrawChunkPicture();
					ChunkSelector.Invalidate();
				}
				else if (e.Button == chunkblockMouseSelect)
				{
					if (!selecting)
						if (Math.Sqrt(Math.Pow(e.X - lastmouse.X, 2) + Math.Pow(e.Y - lastmouse.Y, 2)) > 5)
							selecting = true;
						else
							return;
					SelectedChunkBlock = Rectangle.FromLTRB(Math.Min(SelectedChunkBlock.Left, e.X / 16), Math.Min(SelectedChunkBlock.Top, e.Y / 16), Math.Max(SelectedChunkBlock.Right, e.X / 16 + 1), Math.Max(SelectedChunkBlock.Bottom, e.Y / 16 + 1));
					copiedChunkBlock = (chunkBlockEditor.SelectedObjects = GetSelectedChunkBlocks())[0];
					DrawChunkPicture();
				}
		}

		private void ChunkPicture_MouseUp(object sender, MouseEventArgs e)
		{
			if (!loaded) return;
			if (e.Button == chunkblockMouseDraw)
			{
				LevelData.RedrawChunk(SelectedChunk);
				DrawLevel();
				DrawChunkPicture();
				ChunkSelector.Invalidate();
			}
			else if (e.Button == chunkblockMouseSelect)
			{
				if (!selecting)
				{
					pasteChunkBlocksToolStripMenuItem.Enabled = Clipboard.ContainsData(typeof(RSDKv3_4.Tiles128x128.Block.Tile[,]).AssemblyQualifiedName);
					chunkBlockContextMenuStrip.Show(ChunkPicture, e.Location);
				}
				selecting = false;
			}
		}

		private void ChunkPicture_KeyDown(object sender, KeyEventArgs e)
		{
			if (!loaded) return;
			RSDKv3_4.Tiles128x128.Block.Tile[] blocks = GetSelectedChunkBlocks();
			switch (e.KeyCode)
			{
				case Keys.B:
					foreach (RSDKv3_4.Tiles128x128.Block.Tile item in blocks)
						if (e.Shift)
							item.tileIndex = (ushort)(item.tileIndex == 0 ? LevelData.NewTiles.Length - 1 : item.tileIndex - 1);
						else
							item.tileIndex = (ushort)((item.tileIndex + 1) % LevelData.NewTiles.Length);
					break;
				case Keys.Down:
					if (SelectedChunkBlock.Y < 7)
					{
						SelectedChunkBlock = new Rectangle(SelectedChunkBlock.X, SelectedChunkBlock.Y + 1, 1, 1);
						copiedChunkBlock = LevelData.NewChunks.chunkList[SelectedChunk].tiles[SelectedChunkBlock.Y][SelectedChunkBlock.X];
						blocks = new[] { copiedChunkBlock };
						if (copiedChunkBlock.tileIndex < LevelData.NewTiles.Length)
							TileSelector.SelectedIndex = copiedChunkBlock.tileIndex;
					}
					else
						return;
					break;
				case Keys.End:
					ChunkSelector.SelectedIndex = ChunkSelector.Images.Count - 1;
					return;
				case Keys.Home:
					ChunkSelector.SelectedIndex = 0;
					break;
				case Keys.Left:
					if (SelectedChunkBlock.X > 0)
					{
						SelectedChunkBlock = new Rectangle(SelectedChunkBlock.X - 1, SelectedChunkBlock.Y, 1, 1);
						copiedChunkBlock = LevelData.NewChunks.chunkList[SelectedChunk].tiles[SelectedChunkBlock.Y][SelectedChunkBlock.X];
						blocks = new[] { copiedChunkBlock };
						if (copiedChunkBlock.tileIndex < LevelData.NewTiles.Length)
							TileSelector.SelectedIndex = copiedChunkBlock.tileIndex;
					}
					else
						return;
					break;
				case Keys.PageDown:
					if (ChunkSelector.SelectedIndex < ChunkSelector.Images.Count - 1)
						ChunkSelector.SelectedIndex++;
					return;
				case Keys.PageUp:
					if (ChunkSelector.SelectedIndex > 0)
						ChunkSelector.SelectedIndex--;
					return;
				case Keys.Right:
					if (SelectedChunkBlock.X < 7)
					{
						SelectedChunkBlock = new Rectangle(SelectedChunkBlock.X + 1, SelectedChunkBlock.Y, 1, 1);
						copiedChunkBlock = LevelData.NewChunks.chunkList[SelectedChunk].tiles[SelectedChunkBlock.Y][SelectedChunkBlock.X];
						blocks = new[] { copiedChunkBlock };
						if (copiedChunkBlock.tileIndex < LevelData.NewTiles.Length)
							TileSelector.SelectedIndex = copiedChunkBlock.tileIndex;
					}
					else
						return;
					break;
				case Keys.S:
					foreach (RSDKv3_4.Tiles128x128.Block.Tile item in blocks)
						if (e.Shift)
							item.solidityA--;
						else
							item.solidityA++;
					break;
				case Keys.T:
					foreach (RSDKv3_4.Tiles128x128.Block.Tile item in blocks)
						if (e.Shift)
							item.solidityB--;
						else
							item.solidityB++;
					break;
				case Keys.Up:
					if (SelectedChunkBlock.Y > 0)
					{
						SelectedChunkBlock = new Rectangle(SelectedChunkBlock.X, SelectedChunkBlock.Y - 1, 1, 1);
						copiedChunkBlock = LevelData.NewChunks.chunkList[SelectedChunk].tiles[SelectedChunkBlock.Y][SelectedChunkBlock.X];
						blocks = new[] { copiedChunkBlock };
						if (copiedChunkBlock.tileIndex < LevelData.NewTiles.Length)
							TileSelector.SelectedIndex = copiedChunkBlock.tileIndex;
					}
					else
						return;
					break;
				case Keys.X:
					foreach (RSDKv3_4.Tiles128x128.Block.Tile item in blocks)
						item.direction ^= RSDKv3_4.Tiles128x128.Block.Tile.Directions.FlipX;
					break;
				case Keys.Y:
					foreach (RSDKv3_4.Tiles128x128.Block.Tile item in blocks)
						item.direction ^= RSDKv3_4.Tiles128x128.Block.Tile.Directions.FlipY;
					break;
				default:
					return;
			}
			LevelData.RedrawChunk(SelectedChunk);
			DrawLevel();
			DrawChunkPicture();
			ChunkSelector.Invalidate();
			chunkBlockEditor.SelectedObjects = blocks;
		}

		private void chunkBlockEditor_PropertyValueChanged(object sender, EventArgs e)
		{
			LevelData.RedrawChunk(SelectedChunk);
			DrawLevel();
			DrawChunkPicture();
		}

		private void DrawChunkPicture()
		{
			if (!loaded) return;
			BitmapBits bmp = new BitmapBits(128, 128);
			if (lowToolStripMenuItem.Checked && highToolStripMenuItem.Checked)
				bmp.DrawSprite(LevelData.ChunkSprites[SelectedChunk], 0, 0);
			else if (lowToolStripMenuItem.Checked)
				bmp.DrawSpriteLow(LevelData.ChunkSprites[SelectedChunk], 0, 0);
			else if (highToolStripMenuItem.Checked)
				bmp.DrawSpriteHigh(LevelData.ChunkSprites[SelectedChunk], 0, 0);
			if (path1ToolStripMenuItem.Checked)
				bmp.DrawBitmapComposited(LevelData.ChunkColBmpBits[SelectedChunk][0], 0, 0);
			if (path2ToolStripMenuItem.Checked)
				bmp.DrawBitmapComposited(LevelData.ChunkColBmpBits[SelectedChunk][1], 0, 0);
			bmp.DrawRectangle(LevelData.ColorWhite, SelectedChunkBlock.X * 16 - 1, SelectedChunkBlock.Y * 16 - 1, SelectedChunkBlock.Width * 16 + 1, SelectedChunkBlock.Height * 16 + 1);
			using (Graphics gfx = ChunkPicture.CreateGraphics())
			{
				gfx.SetOptions();
				gfx.DrawImage(bmp.ToBitmap(LevelImgPalette), 0, 0, 128, 128);
			}
		}

		private void ChunkPicture_Paint(object sender, PaintEventArgs e)
		{
			DrawChunkPicture();
		}

		private void flipChunkHButton_Click(object sender, EventArgs e)
		{
			RSDKv3_4.Tiles128x128.Block newcnk = LevelData.NewChunks.chunkList[SelectedChunk].Flip(true, false);
			LevelData.NewChunks.chunkList[SelectedChunk] = newcnk;
			LevelData.RedrawChunk(SelectedChunk);
			copiedChunkBlock = (chunkBlockEditor.SelectedObjects = GetSelectedChunkBlocks())[0];
			if (newcnk.tiles[SelectedChunkBlock.Y][SelectedChunkBlock.X].tileIndex < LevelData.NewTiles.Length)
				TileSelector.SelectedIndex = newcnk.tiles[SelectedChunkBlock.Y][SelectedChunkBlock.X].tileIndex;
			DrawChunkPicture();
			ChunkSelector.Invalidate();
		}

		private void flipChunkVButton_Click(object sender, EventArgs e)
		{
			RSDKv3_4.Tiles128x128.Block newcnk = LevelData.NewChunks.chunkList[SelectedChunk].Flip(false, true);
			LevelData.NewChunks.chunkList[SelectedChunk] = newcnk;
			LevelData.RedrawChunk(SelectedChunk);
			copiedChunkBlock = (chunkBlockEditor.SelectedObjects = GetSelectedChunkBlocks())[0];
			if (newcnk.tiles[SelectedChunkBlock.Y][SelectedChunkBlock.X].tileIndex < LevelData.NewTiles.Length)
				TileSelector.SelectedIndex = newcnk.tiles[SelectedChunkBlock.Y][SelectedChunkBlock.X].tileIndex;
			DrawChunkPicture();
			ChunkSelector.Invalidate();
		}

		Color[,] disppal = null;
		private void DrawPalette()
		{
			if (!loaded) return;
			Color[,] pal = disppal;
			if (pal == null)
			{
				pal = new Color[16, 16];
				for (int y = 0; y < 16; y++)
					for (int x = 0; x < 16; x++)
						pal[y, x] = LevelData.NewPalette[(y * 16) + x];
			}
			for (int y = 0; y < 16; y++)
				for (int x = 0; x < 16; x++)
				{
					PalettePanelGfx.FillRectangle(new SolidBrush(pal[y, x]), x * 20, y * 20, 20, 20);
					PalettePanelGfx.DrawRectangle(Pens.White, x * 20, y * 20, 19, 19);
				}
			if (disppal == null)
				PalettePanelGfx.DrawRectangle(new Pen(Color.Yellow, 2), SelectedColor.X * 20, SelectedColor.Y * 20, 20, 20);
			else if (lastmouse.Y == SelectedColor.Y)
				PalettePanelGfx.DrawRectangle(new Pen(Color.Yellow, 2), lastmouse.X * 20, lastmouse.Y * 20, 20, 20);
			else
				PalettePanelGfx.DrawRectangle(new Pen(Color.Yellow, 2), 0, lastmouse.Y * 20, 320, 20);
		}

		private void PalettePanel_Paint(object sender, PaintEventArgs e)
		{
			DrawPalette();
		}

		int[] cols;
		private void PalettePanel_MouseDoubleClick(object sender, MouseEventArgs e)
		{
			if (!loaded || e.Button != MouseButtons.Left) return;
			int line = e.Y / 20;
			int index = e.X / 20;
			if (index < 0 || index > 15 || line < 0 || line > 15) return;
			SelectedColor = new Point(index, line);
			ColorDialog a = new ColorDialog
			{
				AllowFullOpen = true,
				AnyColor = true,
				FullOpen = true,
				Color = LevelData.NewPalette[(line * 16) + index]
			};
			if (cols != null)
				a.CustomColors = cols;
			if (a.ShowDialog() == DialogResult.OK)
			{
				LevelData.NewPalette[(line * 16) + index] = a.Color;
				LevelData.PaletteChanged();
				loaded = false;
				colorRed.Value = a.Color.R;
				colorGreen.Value = a.Color.G;
				colorBlue.Value = a.Color.B;
				loaded = true;
			}
			cols = a.CustomColors;
		}

		private void color_ValueChanged(object sender, EventArgs e)
		{
			if (!loaded) return;
			LevelData.NewPalette[(SelectedColor.Y * 16) + SelectedColor.X] = Color.FromArgb((byte)colorRed.Value, (byte)colorGreen.Value, (byte)colorBlue.Value);
			LevelData.PaletteChanged();
		}

		private void PalettePanel_MouseDown(object sender, MouseEventArgs e)
		{
			if (!loaded) return;
			Point mouseColor = new Point(e.X / 20, e.Y / 20);
			if (mouseColor.X < 0 || mouseColor.X > 15 || mouseColor.Y < 0 || mouseColor.Y > 15) return;
			if (mouseColor == SelectedColor) return;
			bool newpal = mouseColor.Y != SelectedColor.Y;
			switch (e.Button)
			{
				case MouseButtons.Left:
					SetSelectedColor(mouseColor);
					break;
				case MouseButtons.Right:
					if (!newpal)
					{
						int start = Math.Min(SelectedColor.X, mouseColor.X);
						int end = Math.Max(SelectedColor.X, mouseColor.X);
						if (end - start == 1) return;
						Color startcol = LevelData.NewPalette[(SelectedColor.Y * 16) + start];
						Color endcol = LevelData.NewPalette[(SelectedColor.Y * 16) + end];
						double r = startcol.R;
						double g = startcol.G;
						double b = startcol.B;
						double radd = (endcol.R - startcol.R) / (double)(end - start);
						double gadd = (endcol.G - startcol.G) / (double)(end - start);
						double badd = (endcol.B - startcol.B) / (double)(end - start);
						for (int x = start + 1; x < end; x++)
						{
							r += radd;
							g += gadd;
							b += badd;
							LevelData.NewPalette[(SelectedColor.Y * 16) + x] = Color.FromArgb((int)Math.Round(r, MidpointRounding.AwayFromZero), (int)Math.Round(g, MidpointRounding.AwayFromZero), (int)Math.Round(b, MidpointRounding.AwayFromZero));
						}
						LevelData.PaletteChanged();
					}
					break;
			}
		}

		private void SetSelectedColor(Point color)
		{
			SelectedColor = color;
			lastmouse = color;
			DrawPalette();
			loaded = false;
			colorRed.Value = LevelData.NewPalette[(SelectedColor.Y * 16) + SelectedColor.X].R;
			colorGreen.Value = LevelData.NewPalette[(SelectedColor.Y * 16) + SelectedColor.X].G;
			colorBlue.Value = LevelData.NewPalette[(SelectedColor.Y * 16) + SelectedColor.X].B;
			loaded = true;
		}

		private void PalettePanel_MouseMove(object sender, MouseEventArgs e)
		{
			if (!loaded || e.Button != MouseButtons.Left || !enableDraggingPaletteButton.Checked) return;
			Point mouseColor = new Point(e.X / 20, e.Y / 20);
			if (mouseColor == lastmouse) return;
			if (mouseColor == SelectedColor)
			{
				disppal = null;
				lastmouse = mouseColor;
				DrawPalette();
			}
			if (mouseColor.X < 0 || mouseColor.Y < 0 || mouseColor.X > 15 || mouseColor.Y > 15) return;
			List<List<Point>> palidxs = new List<List<Point>>();
			for (int y = 0; y < 16; y++)
			{
				List<Point> l = new List<Point>();
				for (int x = 0; x < 16; x++)
					l.Add(new Point(x, y));
				palidxs.Add(l);
			}
			if (mouseColor.Y != SelectedColor.Y)
			{
				if (mouseColor.Y == lastmouse.Y)
				{
					lastmouse = mouseColor;
					return;
				}
				if ((ModifierKeys & Keys.Control) == Keys.Control)
					palidxs.Swap(SelectedColor.Y, mouseColor.Y);
				else
					palidxs.Move(SelectedColor.Y, mouseColor.Y > SelectedColor.Y ? mouseColor.Y + 1 : mouseColor.Y);
			}
			else
			{
				if ((ModifierKeys & Keys.Control) == Keys.Control)
					palidxs[mouseColor.Y].Swap(SelectedColor.X, mouseColor.X);
				else
					palidxs[mouseColor.Y].Move(SelectedColor.X, mouseColor.X > SelectedColor.X ? mouseColor.X + 1 : mouseColor.X);
			}
			disppal = new Color[16, 16];
			for (int y = 0; y < 16; y++)
				for (int x = 0; x < 16; x++)
					disppal[y, x] = LevelData.NewPalette[(palidxs[y][x].Y * 16) + palidxs[y][x].X];
			lastmouse = mouseColor;
			DrawPalette();
		}

		private void PalettePanel_MouseUp(object sender, MouseEventArgs e)
		{
			if (!loaded || e.Button != MouseButtons.Left || !enableDraggingPaletteButton.Checked) return;
			Point mouseColor = lastmouse;
			if (mouseColor == SelectedColor) return;
			if (mouseColor.X < 0 || mouseColor.Y < 0 || mouseColor.X > 15 || mouseColor.Y > 15) return;
			disppal = null;
			byte src = (byte)((SelectedColor.Y * 16) + SelectedColor.X);
			byte dst = (byte)((mouseColor.Y * 16) + mouseColor.X);
			Dictionary<byte, byte> map = new Dictionary<byte, byte> { { src, dst } };
			if (ModifierKeys.HasFlag(Keys.Control))
				map[dst] = src;
			else if (src > dst)
			{
				for (byte i = dst; i < src; i++)
					map[i] = (byte)(i + 1);
			}
			else
			{
				for (byte i = dst; i > src; i--)
					map[i] = (byte)(i - 1);
			}
			List<int> tiles = new List<int>();
			for (int t = 0; t < LevelData.NewTiles.Length; t++)
			{
				BitmapBits block = LevelData.NewTiles[t];
				bool edit = false;
				foreach (var item in map)
					if (Array.IndexOf(block.Bits, item.Key) != -1)
					{
						edit = true;
						block.ReplaceColor(item.Key, item.Value);
					}
				if (edit)
					tiles.Add(t);
			}
			if (tiles.Count > 0)
				LevelData.RedrawBlocks(tiles, true);
			Color[] tmp = (Color[])LevelData.NewPalette.Clone();
			foreach (var item in map)
				LevelData.NewPalette[item.Value] = tmp[item.Key];
			SelectedColor = mouseColor;
			LevelData.PaletteChanged();
		}

		private void importPaletteToolStripButton_Click(object sender, EventArgs e)
		{
			/*using (OpenFileDialog a = new OpenFileDialog())
			{
				a.DefaultExt = "bin";
				a.Filter = "MD Palettes|*.bin|Image Files|*.bmp;*.png;*.jpg;*.gif";
				a.RestoreDirectory = true;
				if (a.ShowDialog(this) == DialogResult.OK)
				{
					int l = SelectedColor.Y;
					int x = SelectedColor.X;
					switch (Path.GetExtension(a.FileName))
					{
						case ".bin":
							SonLVLColor[] colors = SonLVLColor.Load(a.FileName, LevelData.Level.PaletteFormat);
							for (int i = 0; i < colors.Length; i++)
							{
								LevelData.Palette[LevelData.CurPal][l, x] = colors[i];
								x++;
								if (x == 16)
								{
									x = 0;
									l++;
									if (l == 4)
										break;
								}
							}
							break;
						case ".bmp":
						case ".png":
						case ".jpg":
						case ".gif":
							using (Bitmap bmp = new Bitmap(a.FileName))
							{
								if ((bmp.PixelFormat & PixelFormat.Indexed) == PixelFormat.Indexed)
								{
									Color[] pal = bmp.Palette.Entries;
									for (int i = 0; i < pal.Length; i++)
									{
										LevelData.ColorToPalette(l, x++, pal[i]);
										if (x == 16)
										{
											x = 0;
											l++;
											if (l == 4)
												break;
										}
									}
								}
								else
									for (int y = 0; y < bmp.Height; y += 8)
									{
										for (int ix = 0; ix < bmp.Width; ix += 8)
										{
											LevelData.ColorToPalette(l, x++, bmp.GetPixel(ix, y));
											if (x == 16)
											{
												x = 0;
												l++;
												if (l == 4)
													break;
											}
										}
										if (l == 4)
											break;
									}
							}
							break;
					}
				}
			}
			LevelData.PaletteChanged();*/
		}

		private void TileSelector_SelectedIndexChanged(object sender, EventArgs e)
		{
			if (TileSelector.SelectedIndex > -1)
			{
				rotateTileRightButton.Enabled = flipTileHButton.Enabled = flipTileVButton.Enabled = true;
				SelectedTile = TileSelector.SelectedIndex;
				TileID.Value = SelectedTile;
				DrawTilePicture();
				if (copiedChunkBlock.tileIndex != SelectedTile)
				{
					copiedChunkBlock = copiedChunkBlock.Clone();
					copiedChunkBlock.tileIndex = (ushort)SelectedTile;
				}
				collisionCeiling.Checked = LevelData.Collision.collisionMasks[collisionLayerSelector.SelectedIndex][SelectedTile].flipY;
				floorAngle.Value = LevelData.Collision.collisionMasks[collisionLayerSelector.SelectedIndex][SelectedTile].floorAngle;
				DrawColPicture();
			}
			else
				rotateTileRightButton.Enabled = flipTileHButton.Enabled = flipTileVButton.Enabled = false;
		}

		private void TilePicture_Paint(object sender, PaintEventArgs e)
		{
			DrawTilePicture();
		}

		private void DrawTilePicture()
		{
			if (TileSelector.SelectedIndex == -1) return;
			using (Graphics gfx = TilePicture.CreateGraphics())
			{
				gfx.SetOptions();
				gfx.DrawImage(LevelData.NewTiles[SelectedTile].Scale(8).ToBitmap(LevelImgPalette), 0, 0, TilePicture.Width, TilePicture.Height);
			}
		}

		private void TilePicture_MouseDown(object sender, MouseEventArgs e)
		{
			if (TileSelector.SelectedIndex == -1) return;
			if (e.Button == MouseButtons.Left)
			{
				LevelData.NewTiles[SelectedTile][e.X / 8, e.Y / 8] = (byte)((SelectedColor.Y * 16) + SelectedColor.X);
				DrawTilePicture();
			}
			else if (e.Button == MouseButtons.Right)
			{
				int y = Math.DivRem(LevelData.NewTiles[SelectedTile][e.X / 8, e.Y / 8], 16, out int x);
				SetSelectedColor(new Point(x, y));
			}
		}

		private void TilePicture_MouseMove(object sender, MouseEventArgs e)
		{
			if (TileSelector.SelectedIndex == -1) return;
			if (e.Button == MouseButtons.Left && new Rectangle(Point.Empty, TilePicture.Size).Contains(e.Location))
			{
				LevelData.NewTiles[SelectedTile][e.X / 8, e.Y / 8] = (byte)((SelectedColor.Y * 16) + SelectedColor.X);
				DrawTilePicture();
			}
		}

		private void TilePicture_MouseUp(object sender, MouseEventArgs e)
		{
			if (TileSelector.SelectedIndex == -1 || e.Button != MouseButtons.Left) return;
			LevelData.RedrawBlock(SelectedTile, true);
			TileSelector.Invalidate();
			chunkBlockEditor.SelectedObjects = chunkBlockEditor.SelectedObjects;
		}

		private void ChunkSelector_MouseDown(object sender, MouseEventArgs e)
		{
			if (!loaded) return;
			if (CurrentTab == Tab.Art & e.Button == MouseButtons.Right)
			{
				pasteOverToolStripMenuItem.Enabled = Clipboard.ContainsData(typeof(RSDKv3_4.Tiles128x128.Block).AssemblyQualifiedName) || Clipboard.ContainsData(typeof(ChunkCopyData).AssemblyQualifiedName);
				duplicateTilesToolStripMenuItem.Enabled = LevelData.HasFreeChunks();
				deepCopyToolStripMenuItem.Visible = true;
				tileContextMenuStrip.Show(ChunkSelector, e.Location);
			}
		}

		private void TileSelector_MouseDown(object sender, MouseEventArgs e)
		{
			if (!loaded) return;
			if (e.Button == MouseButtons.Right)
			{
				pasteOverToolStripMenuItem.Enabled = Clipboard.ContainsData("SonLVLRSDKTile");
				duplicateTilesToolStripMenuItem.Enabled = LevelData.HasFreeTiles();
				deepCopyToolStripMenuItem.Visible = false;
				tileContextMenuStrip.Show(TileSelector, e.Location);
			}
		}

		private void cutTilesToolStripMenuItem_Click(object sender, EventArgs e)
		{
			switch (CurrentArtTab)
			{
				case ArtTab.Chunks:
					Clipboard.SetData(typeof(RSDKv3_4.Tiles128x128.Block).AssemblyQualifiedName, LevelData.NewChunks.chunkList[SelectedChunk]);
					DeleteChunk();
					break;
				case ArtTab.Tiles:
					Clipboard.SetData("SonLVLRSDKTile", LevelData.NewTiles[SelectedTile].Bits);
					DeleteTile();
					break;
			}
		}

		private void DeleteChunk()
		{
			LevelData.NewChunks.chunkList[SelectedChunk] = new RSDKv3_4.Tiles128x128.Block();
		}

		private void DeleteTile()
		{
			LevelData.NewTiles[SelectedTile].Clear();
			TileSelector.Invalidate();
			DrawTilePicture();
			chunkBlockEditor.SelectedObjects = chunkBlockEditor.SelectedObjects;
			LevelData.RedrawBlock(SelectedTile, true);
		}

		private void copyTilesToolStripMenuItem_Click(object sender, EventArgs e)
		{
			switch (CurrentArtTab)
			{
				case ArtTab.Chunks:
					Clipboard.SetData(typeof(RSDKv3_4.Tiles128x128.Block).AssemblyQualifiedName, LevelData.NewChunks.chunkList[SelectedChunk]);
					break;
				case ArtTab.Tiles:
					Clipboard.SetData("SonLVLRSDKTile", LevelData.NewTiles[SelectedTile].Bits);
					break;
			}
		}
		private void duplicateTilesToolStripMenuItem_Click(object sender, EventArgs e)
		{
			switch (CurrentArtTab)
			{
				case ArtTab.Chunks:
					ushort tmp = LevelData.GetFreeChunks().First();
					LevelData.NewChunks.chunkList[tmp] = LevelData.NewChunks.chunkList[SelectedChunk].Clone();
					SelectedChunk = tmp;
					ChunkSelector.SelectedIndex = tmp;
					LevelData.RedrawChunk(tmp);
					break;
				case ArtTab.Tiles:
					tmp = LevelData.GetFreeTiles().First();
					LevelData.NewTiles[tmp] = new BitmapBits(LevelData.NewTiles[SelectedChunk]);
					SelectedTile = tmp;
					TileSelector.SelectedIndex = tmp;
					LevelData.RedrawBlock(tmp, false);
					break;
			}
		}

		private void deleteTilesToolStripMenuItem_Click(object sender, EventArgs e)
		{
			switch (CurrentArtTab)
			{
				case ArtTab.Chunks:
					DeleteChunk();
					break;
				case ArtTab.Tiles:
					DeleteTile();
					break;
			}
		}

		private void importToolStripMenuItem_Click(object sender, EventArgs e)
		{
			using (OpenFileDialog opendlg = new OpenFileDialog())
			{
				opendlg.DefaultExt = "png";
				opendlg.Filter = "Image Files|*.bmp;*.png;*.jpg;*.gif";
				opendlg.RestoreDirectory = true;
				if (opendlg.ShowDialog(this) == DialogResult.OK)
				{
					Bitmap bmp = new Bitmap(opendlg.FileName);
					switch (CurrentArtTab)
					{
						case ArtTab.Chunks:
							if (bmp.Width < 128 || bmp.Height < 128)
							{
								MessageBox.Show(this, $"The image you have selected is too small ({bmp.Width}x{bmp.Height}). It must be at least as large as one chunk (128x128)", "SonLVL-RSDK Chunk Importer", MessageBoxButtons.OK, MessageBoxIcon.Warning);
								bmp.Dispose();
								return;
							}
							break;
						case ArtTab.Tiles:
							if (bmp.Width < 16 || bmp.Height < 16)
							{
								MessageBox.Show(this, $"The image you have selected is too small ({bmp.Width}x{bmp.Height}). It must be at least as large as one tile (16x16)", "SonLVL-RSDK Tile Importer", MessageBoxButtons.OK, MessageBoxIcon.Warning);
								bmp.Dispose();
								return;
							}
							break;
					}
					Bitmap colbmp1 = null, colbmp2 = null, pribmp = null;
					if (CurrentArtTab != ArtTab.Tiles)
					{
						string fmt = Path.Combine(Path.GetDirectoryName(opendlg.FileName),
							Path.GetFileNameWithoutExtension(opendlg.FileName) + "_{0}" + Path.GetExtension(opendlg.FileName));
						if (File.Exists(string.Format(fmt, "col1")))
						{
							colbmp1 = new Bitmap(string.Format(fmt, "col1"));
							if (File.Exists(string.Format(fmt, "col2")))
								colbmp2 = new Bitmap(string.Format(fmt, "col2"));
						}
						else if (File.Exists(string.Format(fmt, "col")))
							colbmp1 = new Bitmap(string.Format(fmt, "col"));
						if (File.Exists(string.Format(fmt, "pri")))
							pribmp = new Bitmap(string.Format(fmt, "pri"));
					}
					ImportImage(bmp, colbmp1, colbmp2, pribmp, null);
				}
			}
		}

		private bool ImportImage(Bitmap bmp, Bitmap colbmp1, Bitmap colbmp2, Bitmap pribmp, ushort[,] layout)
		{
			System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch();
			sw.Start();
			int w = bmp.Width;
			int h = bmp.Height;
			Enabled = false;
			UseWaitCursor = true;
			importProgressControl1_SizeChanged(this, EventArgs.Empty);
			importProgressControl1.CurrentProgress = 0;
			importProgressControl1.MaximumProgress = (w / 16) * (h / 16);
			importProgressControl1.BringToFront();
			importProgressControl1.Show();
			Application.DoEvents();
			BitmapInfo bmpi = new BitmapInfo(bmp);
			Application.DoEvents();
			bmp.Dispose();
			ColInfo[][,] blockcoldata = null;
			if (colbmp1 != null)
			{
				blockcoldata = ProcessColBmps(colbmp1, colbmp2, w, h);
				Application.DoEvents();
			}
			bool[,] priority = new bool[w / 16, h / 16];
			if (pribmp != null)
			{
				using (pribmp)
					LevelData.GetPriMap(pribmp, priority);
				Application.DoEvents();
			}
			byte? forcepal = bmpi.PixelFormat == PixelFormat.Format1bppIndexed || bmpi.PixelFormat == PixelFormat.Format4bppIndexed ? (byte)SelectedColor.Y : (byte?)null;
			Application.DoEvents();
			List<BitmapBits> tiles = new List<BitmapBits>(LevelData.NewTiles);
			List<RSDKv3_4.TileConfig.CollisionMask>[] cols = new[] { new List<RSDKv3_4.TileConfig.CollisionMask>(LevelData.Collision.collisionMasks[0]), new List<RSDKv3_4.TileConfig.CollisionMask>(LevelData.Collision.collisionMasks[1]) };
			List<RSDKv3_4.Tiles128x128.Block> chunks = new List<RSDKv3_4.Tiles128x128.Block>(LevelData.NewChunks.chunkList);
			Application.DoEvents();
			ImportResult ir = LevelData.BitmapToTiles(bmpi, priority, blockcoldata, forcepal, tiles, cols, true, () =>
			{
				importProgressControl1.CurrentProgress++;
				Application.DoEvents();
			});
			List<ushort> freetiles = LevelData.GetFreeTiles().ToList();
			if (ir.Art.Count > freetiles.Count)
			{
				importProgressControl1.Hide();
				Enabled = true;
				UseWaitCursor = false;
				MessageBox.Show(this, "There are " + (ir.Art.Count - freetiles.Count) + " tiles over the limit.\nImport cannot proceed.", "SonLVL-RSDK", MessageBoxButtons.OK, MessageBoxIcon.Warning);
				return false;
			}
			if (ir.Art.Count > 0)
			{
				for (int y = 0; y < ir.Mappings.GetLength(1); y++)
					for (int x = 0; x < ir.Mappings.GetLength(0); x++)
						if (ir.Mappings[x, y].tileIndex >= LevelData.NewTiles.Length)
							ir.Mappings[x, y].tileIndex = freetiles[ir.Mappings[x, y].tileIndex - LevelData.NewTiles.Length];
				for (int i = 0; i < ir.Art.Count; i++)
				{
					ushort ind = freetiles[i];
					LevelData.NewTiles[ind] = ir.Art[i];
					LevelData.RedrawBlock(ind, false);
					if (ir.Collision1 != null)
					{
						LevelData.Collision.collisionMasks[0][ind] = ir.Collision1[i];
						if (ir.Collision2 != null)
							LevelData.Collision.collisionMasks[1][ind] = ir.Collision2[i];
						LevelData.RedrawCol(ind, false);
					}
				}
				TileSelector.Invalidate();
			}
			List<RSDKv3_4.Tiles128x128.Block> newChunks = new List<RSDKv3_4.Tiles128x128.Block>();
			switch (CurrentTab)
			{
				case Tab.Foreground:
				case Tab.Background:
					for (int cy = 0; cy < h / 128; cy++)
						for (int cx = 0; cx < w / 128; cx++)
							ImportChunk(ir.Mappings, chunks, newChunks, layout, cx, cy);
					break;
				case Tab.Art:
					switch (CurrentArtTab)
					{
						case ArtTab.Chunks:
							for (int cy = 0; cy < h / 128; cy++)
								for (int cx = 0; cx < w / 128; cx++)
									ImportChunk(ir.Mappings, chunks, newChunks, layout, cx, cy);
							break;
						case ArtTab.Tiles:
							break;
					}
					break;
			}
			List<ushort> freechunks = LevelData.GetFreeChunks().ToList();
			if (newChunks.Count > freechunks.Count)
			{
				importProgressControl1.Hide();
				Enabled = true;
				UseWaitCursor = false;
				MessageBox.Show(this, "There are " + (newChunks.Count - freechunks.Count) + " chunks over the limit.\nImport cannot proceed.", "SonLVL-RSDK", MessageBoxButtons.OK, MessageBoxIcon.Warning);
				return false;
			}
			if (newChunks.Count > 0)
			{
				for (int cy = 0; cy < h / 128; cy++)
					for (int cx = 0; cx < w / 128; cx++)
						if (layout[cx, cy] >= LevelData.NewChunks.chunkList.Length)
							layout[cx, cy] = freechunks[layout[cx, cy] - LevelData.NewChunks.chunkList.Length];
				foreach (var (cnk, ind) in newChunks.Zip(freechunks, (a, b) => (a, b)))
				{
					Application.DoEvents();
					LevelData.NewChunks.chunkList[ind] = cnk;
					LevelData.RedrawChunk(ind);
				}
				ChunkSelector.Invalidate();
			}
			else if (ir.Art.Count > 0)
				chunkBlockEditor.SelectedObjects = chunkBlockEditor.SelectedObjects;
			sw.Stop();
			System.Text.StringBuilder msg = new System.Text.StringBuilder();
			msg.AppendFormat("New tiles: {0:X}\n", ir.Art.Count);
			msg.AppendFormat("New chunks: {0:X}\n", newChunks.Count);
			msg.Append("\nCompleted in ");
			if (sw.Elapsed.Hours > 0)
			{
				msg.AppendFormat("{0}:{1:00}:{2:00}", sw.Elapsed.Hours, sw.Elapsed.Minutes, sw.Elapsed.Seconds);
				if (sw.Elapsed.Milliseconds > 0)
					msg.AppendFormat(".{000}", sw.Elapsed.Milliseconds);
			}
			else if (sw.Elapsed.Minutes > 0)
			{
				msg.AppendFormat("{0}:{1:00}", sw.Elapsed.Minutes, sw.Elapsed.Seconds);
				if (sw.Elapsed.Milliseconds > 0)
					msg.AppendFormat(".{000}", sw.Elapsed.Milliseconds);
			}
			else
			{
				msg.AppendFormat("{0}", sw.Elapsed.Seconds);
				if (sw.Elapsed.Milliseconds > 0)
					msg.AppendFormat(".{000}", sw.Elapsed.Milliseconds);
			}
			MessageBox.Show(this, msg.ToString(), "Import Results");
			importProgressControl1.Hide();
			Enabled = true;
			UseWaitCursor = false;
			return true;
		}

		private void ImportChunk(RSDKv3_4.Tiles128x128.Block.Tile[,] map, List<RSDKv3_4.Tiles128x128.Block> chunks, List<RSDKv3_4.Tiles128x128.Block> newChunks, ushort[,] layout, int cx, int cy)
		{
			RSDKv3_4.Tiles128x128.Block cnk = new RSDKv3_4.Tiles128x128.Block();
			for (int by = 0; by < 8; by++)
				for (int bx = 0; bx < 8; bx++)
					cnk.tiles[by][bx] = map[cx * 8 + bx, cy * 8 + by];
			for (ushort i = 0; i < chunks.Count; i++)
			{
				Application.DoEvents();
				if (cnk.Equal(chunks[i]))
				{
					if (layout != null)
						layout[cx, cy] = i;
					return;
				}
			}
			chunks.Add(cnk);
			newChunks.Add(cnk);
			if (layout != null)
				layout[cx, cy] = (ushort)(chunks.Count - 1);
		}

		private void DrawColPicture()
		{
			if (TileSelector.SelectedIndex == -1) return;
			using (Graphics gfx = ColPicture.CreateGraphics())
			{
				gfx.SetOptions();
				if (showBlockBehindCollisionCheckBox.Checked)
				{
					BitmapBits bmp = new BitmapBits(16, 16);
					bmp.Bits.FastFill(0xA0);
					bmp.DrawBitmapComposited(LevelData.NewTiles[SelectedTile], 0, 0);
					BitmapBits tmp = new BitmapBits(LevelData.NewColBmpBits[collisionLayerSelector.SelectedIndex][SelectedTile]);
					tmp.IncrementIndexes(LevelData.ColorWhite - 1);
					bmp.DrawBitmapComposited(tmp, 0, 0);
					gfx.DrawImage(bmp.Scale(8).ToBitmap(LevelImgPalette), 0, 0, 128, 128);
				}
				else
					gfx.DrawImage(LevelData.NewColBmpBits[collisionLayerSelector.SelectedIndex][SelectedTile].Scale(8).ToBitmap(Color.Black, Color.White), 0, 0, 128, 128);
			}
		}

		private void ColPicture_Paint(object sender, PaintEventArgs e)
		{
			DrawColPicture();
		}

		private void collisionLayerSelector_SelectedIndexChanged(object sender, EventArgs e)
		{
			if (TileSelector.SelectedIndex == -1) return;
			collisionCeiling.Checked = LevelData.Collision.collisionMasks[collisionLayerSelector.SelectedIndex][SelectedTile].flipY;
			floorAngle.Value = LevelData.Collision.collisionMasks[collisionLayerSelector.SelectedIndex][SelectedTile].floorAngle;
			DrawColPicture();
		}

		private void ColPicture_MouseDown(object sender, MouseEventArgs e)
		{
			if (TileSelector.SelectedIndex == -1) return;
			int x = e.X / 8;
			int y = e.Y / 8;
			if (y == 16)
			{
				LevelData.Collision.collisionMasks[collisionLayerSelector.SelectedIndex][SelectedTile].heightMasks[x].solid = false;
				LevelData.Collision.collisionMasks[collisionLayerSelector.SelectedIndex][SelectedTile].heightMasks[x].height = 0;
			}
			else
			{
				LevelData.Collision.collisionMasks[collisionLayerSelector.SelectedIndex][SelectedTile].heightMasks[x].solid = true;
				LevelData.Collision.collisionMasks[collisionLayerSelector.SelectedIndex][SelectedTile].heightMasks[x].height = (byte)y;
			}
			LevelData.RedrawCol(SelectedTile, false);
			DrawColPicture();
		}

		private void ColPicture_MouseMove(object sender, MouseEventArgs e)
		{
			if (TileSelector.SelectedIndex == -1) return;
			int x = e.X / 8;
			if (x < 0 | x > 15) return;
			int y = e.Y / 8;
			if (y < 0 | y > 16) return;
			if (y == 16)
			{
				LevelData.Collision.collisionMasks[collisionLayerSelector.SelectedIndex][SelectedTile].heightMasks[x].solid = false;
				LevelData.Collision.collisionMasks[collisionLayerSelector.SelectedIndex][SelectedTile].heightMasks[x].height = 0;
			}
			else
			{
				LevelData.Collision.collisionMasks[collisionLayerSelector.SelectedIndex][SelectedTile].heightMasks[x].solid = true;
				LevelData.Collision.collisionMasks[collisionLayerSelector.SelectedIndex][SelectedTile].heightMasks[x].height = (byte)y;
			}
			LevelData.RedrawCol(SelectedTile, false);
			DrawColPicture();
		}

		private void ColPicture_MouseUp(object sender, MouseEventArgs e)
		{
			if (TileSelector.SelectedIndex == -1) return;
			LevelData.RedrawCol(SelectedTile, true);
			DrawColPicture();
		}

		private void collisionCeiling_CheckedChanged(object sender, EventArgs e)
		{
			if (TileSelector.SelectedIndex == -1) return;
			LevelData.Collision.collisionMasks[collisionLayerSelector.SelectedIndex][SelectedTile].flipY = collisionCeiling.Checked;
			LevelData.RedrawCol(SelectedTile, true);
			DrawColPicture();
		}

		private void floorAngle_ValueChanged(object sender, EventArgs e)
		{
			if (TileSelector.SelectedIndex == -1) return;
			LevelData.Collision.collisionMasks[collisionLayerSelector.SelectedIndex][SelectedTile].floorAngle = (byte)floorAngle.Value;
		}

		private void leftAngle_ValueChanged(object sender, EventArgs e)
		{
			if (TileSelector.SelectedIndex == -1) return;
			LevelData.Collision.collisionMasks[collisionLayerSelector.SelectedIndex][SelectedTile].lWallAngle = (byte)leftAngle.Value;
		}

		private void rightAngle_ValueChanged(object sender, EventArgs e)
		{
			if (TileSelector.SelectedIndex == -1) return;
			LevelData.Collision.collisionMasks[collisionLayerSelector.SelectedIndex][SelectedTile].rWallAngle = (byte)rightAngle.Value;
		}

		private void ceilingAngle_ValueChanged(object sender, EventArgs e)
		{
			if (TileSelector.SelectedIndex == -1) return;
			LevelData.Collision.collisionMasks[collisionLayerSelector.SelectedIndex][SelectedTile].roofAngle = (byte)ceilingAngle.Value;
		}

		private void ColAngle_TextChanged(object sender, EventArgs e)
		{
			if (!loaded) return;
			if (byte.TryParse(floorAngle.Text, System.Globalization.NumberStyles.HexNumber, null, out byte value))
				floorAngle.Value = value;
		}

		private void rotateTileRightButton_Click(object sender, EventArgs e)
		{
			LevelData.NewTiles[SelectedTile].Rotate(3);
			LevelData.RedrawBlock(SelectedTile, true);
			chunkBlockEditor.SelectedObjects = chunkBlockEditor.SelectedObjects;
			DrawTilePicture();
		}

		private void drawToolStripButton_Click(object sender, EventArgs e)
		{
			using (DrawTileDialog dlg = new DrawTileDialog())
			{
				switch (CurrentArtTab)
				{
					case ArtTab.Chunks:
						dlg.tile = new BitmapBits(128, 128);
						break;
					case ArtTab.Tiles:
						dlg.tile = new BitmapBits(16, 16);
						break;
				}
				if (dlg.ShowDialog(this) == DialogResult.OK)
					ImportImage(dlg.tile.ToBitmap(LevelData.BmpPal), null, null, null, null);
			}
		}

		private void TileList_KeyDown(object sender, KeyEventArgs e)
		{
			if (CurrentTab > Tab.Background)
			{
				switch (e.KeyCode)
				{
					case Keys.C:
						if (e.Control)
							copyTilesToolStripMenuItem_Click(sender, EventArgs.Empty);
						break;
					case Keys.D:
						if (e.Control)
							switch (CurrentArtTab)
							{
								case ArtTab.Chunks:
									if (LevelData.HasFreeChunks())
										duplicateTilesToolStripMenuItem_Click(sender, EventArgs.Empty);
									break;
								case ArtTab.Tiles:
									if (LevelData.HasFreeTiles())
										duplicateTilesToolStripMenuItem_Click(sender, EventArgs.Empty);
									break;
							}
						break;
					case Keys.Delete:
						switch (CurrentArtTab)
						{
							case ArtTab.Chunks:
								deleteTilesToolStripMenuItem_Click(sender, EventArgs.Empty);
								break;
							case ArtTab.Tiles:
								deleteTilesToolStripMenuItem_Click(sender, EventArgs.Empty);
								break;
						}
						break;
					case Keys.V:
						if (e.Control)
							switch (CurrentArtTab)
							{
								case ArtTab.Chunks:
									if ((Clipboard.ContainsData(typeof(ChunkCopyData).AssemblyQualifiedName) || Clipboard.ContainsData(typeof(RSDKv3_4.Tiles128x128.Block).AssemblyQualifiedName)))
										pasteOverToolStripMenuItem_Click(sender, EventArgs.Empty);
									break;
								case ArtTab.Tiles:
									if (Clipboard.ContainsData("SonLVLRSDKTile"))
										pasteOverToolStripMenuItem_Click(sender, EventArgs.Empty);
									break;
							}
						break;
					case Keys.X:
						if (e.Control)
							switch (CurrentArtTab)
							{
								case ArtTab.Chunks:
									if (LevelData.NewChunks.chunkList.Length > 1)
										cutTilesToolStripMenuItem_Click(sender, EventArgs.Empty);
									break;
								case ArtTab.Tiles:
									if (TileSelector.Images.Count > 1)
										cutTilesToolStripMenuItem_Click(sender, EventArgs.Empty);
									break;
							}
						break;
				}
			}
		}

		private void selectAllObjectsToolStripMenuItem_Click(object sender, EventArgs e)
		{
			SelectedItems = new List<Entry>(LevelData.Objects.Cast<Entry>());
			SelectedObjectChanged();
		}

		private void cutToolStripMenuItem1_Click(object sender, EventArgs e)
		{
			ushort[][] layout;
			Rectangle selection;
			if (CurrentTab == Tab.Background)
			{
				layout = LevelData.Background.layers[bglayer].layout;
				selection = BGSelection;
			}
			else
			{
				layout = LevelData.Scene.layout;
				selection = FGSelection;
			}
			ushort[,] layoutsection = new ushort[selection.Width, selection.Height];
			for (int y = 0; y < selection.Height; y++)
				for (int x = 0; x < selection.Width; x++)
				{
					layoutsection[x, y] = layout[y + selection.Y][x + selection.X];
					layout[y + selection.Y][x + selection.X] = 0;
				}
			List<Entry> objectselection = new List<Entry>();
			List<Entry> objstodelete = new List<Entry>();
			if (includeObjectsWithForegroundSelectionToolStripMenuItem.Checked && CurrentTab == Tab.Foreground)
			{
				int x = selection.Left * 128;
				int y = selection.Top * 128;
				if (LevelData.Objects != null)
					foreach (ObjectEntry item in LevelData.Objects)
						if (item.Y >= y & item.Y < selection.Bottom * 128
							& item.X >= x & item.X < selection.Right * 128)
						{
							Entry ent = item.Clone();
							ent.X -= (ushort)x;
							ent.Y -= (ushort)y;
							objectselection.Add(ent);
							objstodelete.Add(item);
						}
				foreach (Entry item in objstodelete)
				{
					if (item is ObjectEntry oe)
						LevelData.DeleteObject(oe);
					if (SelectedItems.Contains(item))
						SelectedItems.Remove(item);
				}
				SelectedObjectChanged();
			}
			Clipboard.SetData(typeof(LayoutSection).AssemblyQualifiedName, new LayoutSection(layoutsection, objectselection));
			DrawLevel();
		}

		private void copyToolStripMenuItem1_Click(object sender, EventArgs e)
		{
			Clipboard.SetData(typeof(LayoutSection).AssemblyQualifiedName, CreateLayoutSection());
		}

		private LayoutSection CreateLayoutSection()
		{
			ushort[][] layout;
			Rectangle selection;
			if (CurrentTab == Tab.Background)
			{
				layout = LevelData.Background.layers[bglayer].layout;
				selection = BGSelection;
			}
			else
			{
				layout = LevelData.Scene.layout;
				selection = FGSelection;
			}
			ushort[,] layoutsection = new ushort[selection.Width, selection.Height];
			for (int y = 0; y < selection.Height; y++)
				for (int x = 0; x < selection.Width; x++)
					layoutsection[x, y] = layout[y + selection.Y][x + selection.X];
			List<Entry> objectselection = new List<Entry>();
			if (includeObjectsWithForegroundSelectionToolStripMenuItem.Checked && CurrentTab == Tab.Foreground)
			{
				int x = selection.Left * 128;
				int y = selection.Top * 128;
				if (LevelData.Objects != null)
					foreach (ObjectEntry item in LevelData.Objects)
						if (item.Y >= y & item.Y < selection.Bottom * 128
							& item.X >= x & item.X < selection.Right * 128)
						{
							Entry ent = item.Clone();
							ent.X -= (ushort)x;
							ent.Y -= (ushort)y;
							objectselection.Add(ent);
						}
			}
			return new LayoutSection(layoutsection, objectselection);
		}

		private void pasteOnceToolStripMenuItem_Click(object sender, EventArgs e)
		{
			LayoutSection section = (LayoutSection)Clipboard.GetData(typeof(LayoutSection).AssemblyQualifiedName);
			PasteLayoutSectionOnce(section);
		}

		private void PasteLayoutSectionOnce(LayoutSection section)
		{
			ushort[][] layout;
			int w, h;
			if (CurrentTab == Tab.Background)
			{
				layout = LevelData.Background.layers[bglayer].layout;
				w = Math.Min(section.Layout.GetLength(0), LevelData.BGWidth[bglayer] - menuLoc.X);
				h = Math.Min(section.Layout.GetLength(1), LevelData.BGHeight[bglayer] - menuLoc.Y);
			}
			else
			{
				layout = LevelData.Scene.layout;
				w = Math.Min(section.Layout.GetLength(0), LevelData.FGWidth - menuLoc.X);
				h = Math.Min(section.Layout.GetLength(1), LevelData.FGHeight - menuLoc.Y);
			}
			for (int y = 0; y < h; y++)
				for (int x = 0; x < w; x++)
					layout[y + menuLoc.Y][x + menuLoc.X] = section.Layout[x, y];
			if (includeObjectsWithForegroundSelectionToolStripMenuItem.Checked && CurrentTab == Tab.Foreground)
			{
				Size off = new Size(menuLoc.X * 128, menuLoc.Y * 128);
				foreach (Entry item in section.Objects)
				{
					Entry newent = item.Clone();
					newent.X = (ushort)(newent.X + off.Width);
					newent.Y = (ushort)(newent.Y + off.Height);
					if (newent is ObjectEntry)
						LevelData.AddObject((ObjectEntry)newent);
					newent.UpdateSprite();
				}
				LevelData.Objects.Sort();
			}
			DrawLevel();
		}

		private void pasteRepeatingToolStripMenuItem_Click(object sender, EventArgs e)
		{
			LayoutSection section = (LayoutSection)Clipboard.GetData(typeof(LayoutSection).AssemblyQualifiedName);
			PasteLayoutSectionRepeating(section);
		}

		private void PasteLayoutSectionRepeating(LayoutSection section)
		{
			ushort[][] layout;
			Rectangle selection;
			if (CurrentTab == Tab.Background)
			{
				layout = LevelData.Background.layers[bglayer].layout;
				selection = BGSelection;
			}
			else
			{
				layout = LevelData.Scene.layout;
				selection = FGSelection;
			}
			int width = section.Layout.GetLength(0);
			int height = section.Layout.GetLength(1);
			for (int y = 0; y < selection.Height; y++)
				for (int x = 0; x < selection.Width; x++)
					layout[y + selection.Y][x + selection.X] = section.Layout[x % width, y % height];
			if (includeObjectsWithForegroundSelectionToolStripMenuItem.Checked && CurrentTab == Tab.Foreground)
			{
				int w = (int)Math.Ceiling(selection.Width / (double)width);
				int h = (int)Math.Ceiling(selection.Height / (double)height);
				Point bottomright = new Point(selection.Right * 128, selection.Bottom * 128);
				for (int y = 0; y < h; y++)
					for (int x = 0; x < w; x++)
					{
						Size off = new Size((selection.X + (x * width)) * 128, (selection.Y + (y * height)) * 128);
						foreach (Entry item in section.Objects)
						{
							Entry it2 = item.Clone();
							it2.X = (ushort)(it2.X + off.Width);
							it2.Y = (ushort)(it2.Y + off.Height);
							if (it2.X < bottomright.X & it2.Y < bottomright.Y)
							{
								if (it2 is ObjectEntry)
									LevelData.AddObject((ObjectEntry)it2);
								it2.UpdateSprite();
							}
						}
					}
				LevelData.Objects.Sort();
			}
			DrawLevel();
		}

		private void deleteToolStripMenuItem1_Click(object sender, EventArgs e)
		{
			ushort[][] layout;
			Rectangle selection;
			if (CurrentTab == Tab.Background)
			{
				layout = LevelData.Background.layers[bglayer].layout;
				selection = BGSelection;
			}
			else
			{
				layout = LevelData.Scene.layout;
				selection = FGSelection;
			}
			for (int y = selection.Top; y < selection.Bottom; y++)
				for (int x = selection.Left; x < selection.Right; x++)
					layout[y][x] = 0;
			if (includeObjectsWithForegroundSelectionToolStripMenuItem.Checked & CurrentTab == Tab.Foreground)
			{
				List<Entry> objectselection = new List<Entry>();
				if (LevelData.Objects != null)
					foreach (ObjectEntry item in LevelData.Objects)
						if (item.Y >= selection.Top * 128 & item.Y < selection.Bottom * 128
							& item.X >= selection.Left * 128 & item.X < selection.Right * 128)
							objectselection.Add(item);
				foreach (Entry item in objectselection)
				{
					if (item is ObjectEntry)
						LevelData.DeleteObject((ObjectEntry)item);
					if (SelectedItems.Contains(item))
						SelectedItems.Remove(item);
				}
				SelectedObjectChanged();
			}
			DrawLevel();
		}

		private void fillToolStripMenuItem_Click(object sender, EventArgs e)
		{
			ushort[][] layout;
			Rectangle selection;
			if (CurrentTab == Tab.Background)
			{
				layout = LevelData.Background.layers[bglayer].layout;
				selection = BGSelection;
			}
			else
			{
				layout = LevelData.Scene.layout;
				selection = FGSelection;
			}
			for (int y = selection.Top; y < selection.Bottom; y++)
				for (int x = selection.Left; x < selection.Right; x++)
					layout[y][x] = SelectedChunk;
			DrawLevel();
		}

		private void resizeLevelToolStripMenuItem_Click(object sender, EventArgs e)
		{
			using (ResizeLevelDialog dg = new ResizeLevelDialog())
			{
				Size cursize;
				if (CurrentTab == Tab.Background)
					cursize = LevelData.BGSize[bglayer];
				else
					cursize = LevelData.FGSize;
				dg.levelHeight.Value = cursize.Height;
				dg.levelWidth.Value = cursize.Width;
				if (dg.ShowDialog(this) == DialogResult.OK)
				{
					if (CurrentTab == Tab.Background)
						LevelData.ResizeBG(bglayer, (int)dg.levelWidth.Value, (int)dg.levelHeight.Value);
					else
						LevelData.ResizeFG((int)dg.levelWidth.Value, (int)dg.levelHeight.Value);
					loaded = false;
					UpdateScrollBars();
					loaded = true;
					DrawLevel();
				}
			}
		}

		private void objectTypeList_ItemDrag(object sender, ItemDragEventArgs e)
		{
			objectTypeList.DoDragDrop(new DataObject("SonicRetro.SonLVLRSDK.GUI.ObjectDrop", ((ListViewItem)e.Item).Tag), DragDropEffects.Copy);
		}

		private void objectPanel_DragEnter(object sender, DragEventArgs e)
		{
			if (e.Data.GetDataPresent("SonicRetro.SonLVLRSDK.GUI.ObjectDrop"))
			{
				e.Effect = DragDropEffects.All;
				dragdrop = true;
				dragobj = (byte)e.Data.GetData("SonicRetro.SonLVLRSDK.GUI.ObjectDrop");
				dragpoint = objectPanel.PanelPointToClient(new Point(e.X, e.Y));
				dragpoint = new Point((int)(dragpoint.X / ZoomLevel), (int)(dragpoint.Y / ZoomLevel));
				DrawLevel();
			}
			else
				dragdrop = false;
		}

		private void objectPanel_DragOver(object sender, DragEventArgs e)
		{
			if (e.Data.GetDataPresent("SonicRetro.SonLVLRSDK.GUI.ObjectDrop"))
			{
				e.Effect = DragDropEffects.All;
				dragdrop = true;
				dragobj = (byte)e.Data.GetData("SonicRetro.SonLVLRSDK.GUI.ObjectDrop");
				dragpoint = objectPanel.PanelPointToClient(new Point(e.X, e.Y));
				dragpoint = new Point((int)(dragpoint.X / ZoomLevel), (int)(dragpoint.Y / ZoomLevel));
				DrawLevel();
			}
			else
				dragdrop = false;
		}

		private void objectPanel_DragLeave(object sender, EventArgs e)
		{
			dragdrop = false;
			DrawLevel();
		}

		private void objectPanel_DragDrop(object sender, DragEventArgs e)
		{
			dragdrop = false;
			if (e.Data.GetDataPresent("SonicRetro.SonLVLRSDK.GUI.ObjectDrop"))
			{
				double gs = 1 << ObjGrid;
				Point clientPoint = objectPanel.PanelPointToClient(new Point(e.X, e.Y));
				clientPoint = new Point((int)(clientPoint.X / ZoomLevel), (int)(clientPoint.Y / ZoomLevel));
				ObjectEntry obj = LevelData.CreateObject((byte)e.Data.GetData("SonicRetro.SonLVLRSDK.GUI.ObjectDrop"));
				obj.X = (ushort)(Math.Round((clientPoint.X + objectPanel.HScrollValue) / gs, MidpointRounding.AwayFromZero) * gs);
				obj.Y = (ushort)(Math.Round((clientPoint.Y + objectPanel.VScrollValue) / gs, MidpointRounding.AwayFromZero) * gs);
				obj.UpdateSprite();
				LevelData.Objects.Add(obj);
				LevelData.Objects.Sort();
				SelectedItems = new List<Entry>(1) { obj };
				SelectedObjectChanged();
				DrawLevel();
			}
		}

		private void insertLayoutToolStripMenuItem_Click(object sender, EventArgs e)
		{
			using (InsertDeleteDialog dlg = new InsertDeleteDialog())
			{
				dlg.Text = "Insert";
				dlg.moveObjects.Visible = dlg.moveObjects.Checked = CurrentTab == Tab.Foreground;
				if (dlg.ShowDialog(this) != DialogResult.OK) return;
				Rectangle selection;
				if (CurrentTab == Tab.Background)
					selection = BGSelection;
				else
					selection = FGSelection;
				if (dlg.shiftH.Checked)
				{
					ushort[][] layout;
					if (CurrentTab == Tab.Background)
					{
						if (LevelData.BGWidth[bglayer] < 255)
							LevelData.ResizeBG(bglayer, Math.Min(255, LevelData.BGWidth[bglayer] + selection.Width), LevelData.BGHeight[bglayer]);
						layout = LevelData.Background.layers[bglayer].layout;
					}
					else
					{
						if (LevelData.FGWidth < 255)
							LevelData.ResizeFG(Math.Min(255, LevelData.FGWidth + selection.Width), LevelData.FGHeight);
						layout = LevelData.Scene.layout;
					}
					for (int y = selection.Top; y < selection.Bottom; y++)
						for (int x = layout[y].Length - selection.Width - 1; x >= selection.Left; x--)
							layout[y][x + selection.Width] = layout[y][x];
					for (int y = selection.Top; y < selection.Bottom; y++)
						for (int x = selection.Left; x < selection.Right; x++)
							layout[y][x] = 0;
					if (dlg.moveObjects.Checked)
					{
						if (LevelData.Objects != null)
							foreach (ObjectEntry item in LevelData.Objects)
								if (item.Y >= selection.Top * 128 && item.Y < selection.Bottom * 128 && item.X >= selection.Left * 128)
								{
									item.X += (ushort)(selection.Width * 128);
									item.UpdateSprite();
								}
					}
				}
				else if (dlg.shiftV.Checked)
				{
					ushort[][] layout;
					if (CurrentTab == Tab.Background)
					{
						if (LevelData.BGHeight[bglayer] < 255)
							LevelData.ResizeBG(bglayer, LevelData.BGWidth[bglayer], Math.Min(255, LevelData.BGHeight[bglayer] + selection.Height));
						layout = LevelData.Background.layers[bglayer].layout;
					}
					else
					{
						if (LevelData.FGHeight < 255)
							LevelData.ResizeFG(LevelData.FGWidth, Math.Min(255, LevelData.FGHeight + selection.Height));
						layout = LevelData.Scene.layout;
					}
					for (int x = selection.Left; x < selection.Right; x++)
						for (int y = layout.Length - selection.Height - 1; y >= selection.Top; y--)
							layout[y + selection.Height][x] = layout[y][x];
					for (int x = selection.Left; x < selection.Right; x++)
						for (int y = selection.Top; y < selection.Bottom; y++)
							layout[y][x] = 0;
					if (dlg.moveObjects.Checked)
					{
						if (LevelData.Objects != null)
							foreach (ObjectEntry item in LevelData.Objects)
								if (item.X >= selection.Left * 128 && item.X < selection.Right * 128 && item.Y >= selection.Top * 128)
								{
									item.Y += (ushort)(selection.Height * 128);
									item.UpdateSprite();
								}
					}
				}
				else if (dlg.entireRow.Checked)
				{
					ushort[][] layout;
					int width;
					if (CurrentTab == Tab.Background)
					{
						width = LevelData.BGWidth[bglayer];
						if (LevelData.BGHeight[bglayer] < 255)
							LevelData.ResizeBG(bglayer, width, Math.Min(255, LevelData.BGHeight[bglayer] + selection.Height));
						layout = LevelData.Background.layers[bglayer].layout;
					}
					else
					{
						width = LevelData.FGWidth;
						if (LevelData.FGHeight < 255)
							LevelData.ResizeFG(width, Math.Min(255, LevelData.FGHeight + selection.Height));
						layout = LevelData.Scene.layout;
					}
					for (int x = 0; x < width; x++)
						for (int y = layout.Length - selection.Height - 1; y >= selection.Top; y--)
							layout[y + selection.Height][x] = layout[y][x];
					for (int x = 0; x < width; x++)
						for (int y = selection.Top; y < selection.Bottom; y++)
							layout[y][x] = 0;
					if (dlg.moveObjects.Checked)
					{
						if (LevelData.Objects != null)
							foreach (ObjectEntry item in LevelData.Objects)
								if (item.Y >= selection.Top * 128)
								{
									item.Y += (ushort)(selection.Height * 128);
									item.UpdateSprite();
								}
					}
				}
				else if (dlg.entireColumn.Checked)
				{
					ushort[][] layout;
					if (CurrentTab == Tab.Background)
					{
						if (LevelData.BGWidth[bglayer] < 255)
							LevelData.ResizeBG(bglayer, Math.Min(255, LevelData.BGWidth[bglayer] + selection.Width), LevelData.BGHeight[bglayer]);
						layout = LevelData.Background.layers[bglayer].layout;
					}
					else
					{
						if (LevelData.FGWidth < 255)
							LevelData.ResizeFG(Math.Min(255, LevelData.FGWidth + selection.Width), LevelData.FGHeight);
						layout = LevelData.Scene.layout;
					}
					for (int y = 0; y < layout.Length; y++)
						for (int x = layout[y].Length - selection.Width - 1; x >= selection.Left; x--)
							layout[y][x + selection.Width] = layout[y][x];
					for (int y = 0; y < layout.Length; y++)
						for (int x = selection.Left; x < selection.Right; x++)
							layout[y][x] = 0;
					if (dlg.moveObjects.Checked)
					{
						if (LevelData.Objects != null)
							foreach (ObjectEntry item in LevelData.Objects)
								if (item.X >= selection.Left * 128)
								{
									item.X += (ushort)(selection.Width * 128);
									item.UpdateSprite();
								}
					}
				}
				DrawLevel();
			}
		}

		private void deleteLayoutToolStripMenuItem_Click(object sender, EventArgs e)
		{
			using (InsertDeleteDialog dlg = new InsertDeleteDialog())
			{
				dlg.Text = "Delete";
				dlg.shiftH.Text = "Shift cells left";
				dlg.shiftV.Text = "Shift cells up";
				dlg.moveObjects.Visible = dlg.moveObjects.Checked = CurrentTab == Tab.Foreground;
				if (dlg.ShowDialog(this) != DialogResult.OK) return;
				Rectangle selection;
				if (CurrentTab == Tab.Background)
					selection = BGSelection;
				else
					selection = FGSelection;
				if (dlg.shiftH.Checked)
				{
					ushort[][] layout;
					if (CurrentTab == Tab.Background)
						layout = LevelData.Background.layers[bglayer].layout;
					else
						layout = LevelData.Scene.layout;
					for (int y = selection.Top; y < selection.Bottom; y++)
						for (int x = selection.Left; x < layout[y].Length - selection.Width; x++)
							layout[y][x] = layout[y][x + selection.Width];
					for (int y = selection.Top; y < selection.Bottom; y++)
						for (int x = layout[y].Length - selection.Width; x < layout[y].Length; x++)
							layout[y][x] = 0;
					if (dlg.moveObjects.Checked)
					{
						if (LevelData.Objects != null)
							foreach (ObjectEntry item in LevelData.Objects)
								if (item.Y >= selection.Top * 128 & item.Y < selection.Bottom * 128 & item.X >= selection.Right * 128)
								{
									item.X -= (ushort)(selection.Width * 128);
									item.UpdateSprite();
								}
					}
				}
				else if (dlg.shiftV.Checked)
				{
					ushort[][] layout;
					if (CurrentTab == Tab.Background)
						layout = LevelData.Background.layers[bglayer].layout;
					else
						layout = LevelData.Scene.layout;
					for (int x = selection.Left; x < selection.Right; x++)
						for (int y = selection.Top; y < layout.Length - selection.Height; y++)
							layout[y][x] = layout[y + selection.Height][x];
					for (int x = selection.Left; x < selection.Right; x++)
						for (int y = layout.Length - selection.Height; y < layout.Length; y++)
							layout[y][x] = 0;
					if (dlg.moveObjects.Checked)
					{
						if (LevelData.Objects != null)
							foreach (ObjectEntry item in LevelData.Objects)
								if (item.X >= selection.Left * 128 & item.X < selection.Right * 128 & item.Y >= selection.Bottom * 128)
								{
									item.Y -= (ushort)(selection.Height * 128);
									item.UpdateSprite();
								}
					}
				}
				else if (dlg.entireRow.Checked)
				{
					ushort[][] layout;
					int width;
					if (CurrentTab == Tab.Background)
					{
						layout = LevelData.Background.layers[bglayer].layout;
						width = LevelData.BGWidth[bglayer];
					}
					else
					{
						layout = LevelData.Scene.layout;
						width = LevelData.FGWidth;
					}
					for (int x = 0; x < width; x++)
						for (int y = selection.Top; y < layout.Length - selection.Height; y++)
							layout[y][x] = layout[y + selection.Height][x];
					for (int x = 0; x < width; x++)
						for (int y = layout.Length - selection.Height; y < layout.Length; y++)
							layout[y][x] = 0;
					if (dlg.moveObjects.Checked)
					{
						if (LevelData.Objects != null)
							foreach (ObjectEntry item in LevelData.Objects)
								if (item.Y >= selection.Bottom * 128)
								{
									item.Y -= (ushort)(selection.Height * 128);
									item.UpdateSprite();
								}
					}
					if (CurrentTab == Tab.Background)
					{
						if (LevelData.BGHeight[bglayer] > selection.Height)
							LevelData.ResizeBG(bglayer, LevelData.BGWidth[bglayer], LevelData.BGHeight[bglayer] - selection.Height);
					}
					else
					{
						if (LevelData.FGHeight > selection.Height)
							LevelData.ResizeFG(LevelData.FGWidth, LevelData.FGHeight - selection.Height);
					}
				}
				else if (dlg.entireColumn.Checked)
				{
					ushort[][] layout;
					if (CurrentTab == Tab.Background)
						layout = LevelData.Background.layers[bglayer].layout;
					else
						layout = LevelData.Scene.layout;
					for (int y = 0; y < layout.Length; y++)
						for (int x = selection.Left; x < layout[y].Length - selection.Width; x++)
							layout[y][x] = layout[y][x + selection.Width];
					for (int y = 0; y < layout.Length; y++)
						for (int x = layout[y].Length - selection.Width; x < layout[y].Length; x++)
							layout[y][x] = 0;
					if (dlg.moveObjects.Checked)
					{
						if (LevelData.Objects != null)
							foreach (ObjectEntry item in LevelData.Objects)
								if (item.X >= selection.Right * 128)
								{
									item.X -= (ushort)(selection.Width * 128);
									item.UpdateSprite();
								}
					}
					if (CurrentTab == Tab.Background)
					{
						if (LevelData.BGWidth[bglayer] > selection.Width)
							LevelData.ResizeBG(bglayer, LevelData.BGWidth[bglayer] - selection.Width, LevelData.BGHeight[bglayer]);
					}
					else
					{
						if (LevelData.FGWidth > selection.Width)
							LevelData.ResizeFG(LevelData.FGWidth - selection.Width, LevelData.FGHeight);
					}
				}
			}
		}

		private bool alignWall_common(int x, int y, bool top)
		{
			int cnkx = Math.DivRem(x, 128, out int blkx);
			int cnky = Math.DivRem(y, 128, out int blky);
			blkx = Math.DivRem(blkx, 16, out int colx);
			blky = Math.DivRem(blky, 16, out int coly);

			RSDKv3_4.Tiles128x128.Block.Tile blk = LevelData.NewChunks.chunkList[LevelData.Scene.layout[cnky][cnkx]].tiles[blky][blkx];
			RSDKv3_4.Tiles128x128.Block.Tile.Solidities solid;
			RSDKv3_4.TileConfig.CollisionMask mask;
			if (path2ToolStripMenuItem.Checked)
			{
				solid = blk.solidityB;
				mask = LevelData.Collision.collisionMasks[1][blk.tileIndex];
			}
			else
			{
				solid = blk.solidityA;
				mask = LevelData.Collision.collisionMasks[0][blk.tileIndex];
			}
			if (top)
				switch (solid)
				{
					case RSDKv3_4.Tiles128x128.Block.Tile.Solidities.SolidAllButTop:
					case RSDKv3_4.Tiles128x128.Block.Tile.Solidities.SolidNone:
						return false;
				}
			else
				switch (solid)
				{
					case RSDKv3_4.Tiles128x128.Block.Tile.Solidities.SolidTop:
					case RSDKv3_4.Tiles128x128.Block.Tile.Solidities.SolidNone:
						return false;
				}
			var height = mask.heightMasks[colx];
			if (!height.solid)
				return false;
			if (mask.flipY)
				return coly <= height.height;
			else
				return coly >= height.height;
		}

		private void alignLeftWallToolStripButton_Click(object sender, EventArgs e)
		{
			foreach (Entry item in SelectedItems)
			{
				Rectangle bounds = item.Bounds;
				int x = bounds.Left - 1;
				int y = bounds.Top + (bounds.Height / 2);
				while (x > 0)
				{
					if (alignWall_common(x, y, false))
						break;
					x--;
				}
				item.X = (ushort)(x + 1 + (item.X - bounds.Left));
				item.UpdateSprite();
			}
			SelectedObjectChanged();
			ScrollToObject(SelectedItems[0]);
			DrawLevel();
		}

		private void alignGroundToolStripButton_Click(object sender, EventArgs e)
		{
			foreach (Entry item in SelectedItems)
			{
				Rectangle bounds = item.Bounds;
				int x = bounds.Left + (bounds.Width / 2);
				int y = bounds.Bottom;
				while (y < LevelData.FGHeight * 128 - 1)
				{
					if (alignWall_common(x, y, true))
						break;
					y++;
				}
				item.Y = (ushort)(y + (item.Y - bounds.Bottom));
				item.UpdateSprite();
			}
			SelectedObjectChanged();
			ScrollToObject(SelectedItems[0]);
			DrawLevel();
		}

		private void alignRightWallToolStripButton_Click(object sender, EventArgs e)
		{
			foreach (Entry item in SelectedItems)
			{
				Rectangle bounds = item.Bounds;
				int x = bounds.Right;
				int y = bounds.Top + (bounds.Height / 2);
				while (x < LevelData.FGWidth * 128 - 1)
				{
					if (alignWall_common(x, y, false))
						break;
					x++;
				}
				item.X = (ushort)(x + (item.X - bounds.Right));
				item.UpdateSprite();
			}
			SelectedObjectChanged();
			ScrollToObject(SelectedItems[0]);
			DrawLevel();
		}

		private void alignCeilingToolStripButton_Click(object sender, EventArgs e)
		{
			foreach (Entry item in SelectedItems)
			{
				Rectangle bounds = item.Bounds;
				int x = bounds.Left + (bounds.Width / 2);
				int y = bounds.Top - 1;
				while (y > 0)
				{
					if (alignWall_common(x, y, false))
						break;
					y--;
				}
				item.Y = (ushort)(y + 1 + (item.Y - bounds.Top));
				item.UpdateSprite();
			}
			SelectedObjectChanged();
			ScrollToObject(SelectedItems[0]);
			DrawLevel();
		}

		private void alignLeftsToolStripButton_Click(object sender, EventArgs e)
		{
			int left = int.MaxValue;
			foreach (Entry item in SelectedItems)
				left = Math.Min(left, item.Bounds.Left);
			foreach (Entry item in SelectedItems)
			{
				item.X = (ushort)(left + (item.X - item.Bounds.Left));
				item.UpdateSprite();
			}
			SelectedObjectChanged();
			ScrollToObject(SelectedItems[0]);
			DrawLevel();
		}

		private void alignCentersToolStripButton_Click(object sender, EventArgs e)
		{
			int left = int.MaxValue;
			int right = int.MinValue;
			foreach (Entry item in SelectedItems)
			{
				Rectangle bounds = item.Bounds;
				left = Math.Min(left, bounds.Left);
				right = Math.Max(right, bounds.Right);
			}
			int center = left + (right - left) / 2;
			foreach (Entry item in SelectedItems)
			{
				Rectangle bounds = item.Bounds;
				item.X = (ushort)(center + (item.X - (bounds.Left + (bounds.Width / 2))));
				item.UpdateSprite();
			}
			SelectedObjectChanged();
			ScrollToObject(SelectedItems[0]);
			DrawLevel();
		}

		private void alignRightsToolStripButton_Click(object sender, EventArgs e)
		{
			int right = int.MinValue;
			foreach (Entry item in SelectedItems)
				right = Math.Max(right, item.Bounds.Right);
			foreach (Entry item in SelectedItems)
			{
				item.X = (ushort)(right + (item.X - item.Bounds.Right));
				item.UpdateSprite();
			}
			SelectedObjectChanged();
			ScrollToObject(SelectedItems[0]);
			DrawLevel();
		}

		private void alignTopsToolStripButton_Click(object sender, EventArgs e)
		{
			int top = int.MaxValue;
			foreach (Entry item in SelectedItems)
				top = Math.Min(top, item.Bounds.Top);
			foreach (Entry item in SelectedItems)
			{
				item.Y = (ushort)(top + (item.Y - item.Bounds.Top));
				item.UpdateSprite();
			}
			SelectedObjectChanged();
			ScrollToObject(SelectedItems[0]);
			DrawLevel();
		}

		private void alignMiddlesToolStripButton_Click(object sender, EventArgs e)
		{
			int top = int.MaxValue;
			int bottom = int.MinValue;
			foreach (Entry item in SelectedItems)
			{
				Rectangle bounds = item.Bounds;
				top = Math.Min(top, bounds.Top);
				bottom = Math.Max(bottom, bounds.Bottom);
			}
			int middle = top + (bottom - top) / 2;
			foreach (Entry item in SelectedItems)
			{
				Rectangle bounds = item.Bounds;
				item.Y = (ushort)(middle + (item.Y - (bounds.Top + (bounds.Height / 2))));
				item.UpdateSprite();
			}
			SelectedObjectChanged();
			ScrollToObject(SelectedItems[0]);
			DrawLevel();
		}

		private void alignBottomsToolStripButton_Click(object sender, EventArgs e)
		{
			int bottom = int.MinValue;
			foreach (Entry item in SelectedItems)
				bottom = Math.Max(bottom, item.Bounds.Bottom);
			foreach (Entry item in SelectedItems)
			{
				item.Y = (ushort)(bottom + (item.Y - item.Bounds.Bottom));
				item.UpdateSprite();
			}
			SelectedObjectChanged();
			ScrollToObject(SelectedItems[0]);
			DrawLevel();
		}

		List<ObjectEntry> foundobjs;
		int lastfoundobj;
		Point? lastfoundfgchunk;
		byte searchfgchunk;
		Point? lastfoundbgchunk;
		byte searchbgchunk;
		private void findToolStripMenuItem_Click(object sender, EventArgs e)
		{
			switch (CurrentTab)
			{
				case Tab.Objects:
					DialogResult res = findObjectsDialog.ShowDialog(this);
					if (res != DialogResult.Yes && res != DialogResult.OK)
						return;
					foundobjs = new List<ObjectEntry>(LevelData.Objects);
					byte? id = findObjectsDialog.ID;
					if (id.HasValue)
						foundobjs = new List<ObjectEntry>(foundobjs.Where(a => a.ID == id.Value));
					byte? sub = findObjectsDialog.SubType;
					if (sub.HasValue)
						foundobjs = new List<ObjectEntry>(foundobjs.Where(a => a.SubType == sub.Value));
					SelectedItems.Clear();
					switch (res)
					{
						case DialogResult.Yes:
							SelectedItems.AddRange(foundobjs.OfType<Entry>());
							if (SelectedItems.Count > 0)
								MessageBox.Show(this, SelectedItems.Count + " object" + (SelectedItems.Count > 1 ? "s" : "") + " found.",
									"SonLVL-RSDK");
							break;
						case DialogResult.OK:
							if (foundobjs.Count > 0)
								SelectedItems.Add(foundobjs[0]);
							break;
					}
					if (SelectedItems.Count > 0)
					{
						ScrollToObject(SelectedItems[0]);
						lastfoundobj = 0;
						findNextToolStripMenuItem.Enabled = foundobjs.Count > 1;
						findPreviousToolStripMenuItem.Enabled = false;
					}
					else
					{
						MessageBox.Show(this, "No matching objects found.", "SonLVL-RSDK");
						findNextToolStripMenuItem.Enabled = findPreviousToolStripMenuItem.Enabled = false;
						foundobjs = null;
					}
					SelectedObjectChanged();
					DrawLevel();
					break;
				case Tab.Foreground:
					switch (findFGChunksDialog.ShowDialog(this))
					{
						case DialogResult.Yes:
							int count = 0;
							for (int x = 0; x < LevelData.FGWidth; x++)
								for (int y = 0; y < LevelData.FGHeight; y++)
									if (LevelData.Scene.layout[y][x] == findFGChunksDialog.chunkSelect.Value)
										count++;
							MessageBox.Show(this, count + " chunk" + (count != 1 ? "s" : "") + " found.",
								"SonLVL-RSDK");
							break;
						case DialogResult.OK:
							for (int x = 0; x < LevelData.FGWidth; x++)
								for (int y = 0; y < LevelData.FGHeight; y++)
									if (LevelData.Scene.layout[y][x] == findFGChunksDialog.chunkSelect.Value)
									{
										lastfoundfgchunk = new Point(x, y);
										searchfgchunk = (byte)findFGChunksDialog.chunkSelect.Value;
										findNextToolStripMenuItem.Enabled = true;
										findPreviousToolStripMenuItem.Enabled = false;
										FGSelection = new Rectangle(x, y, 1, 1);
										loaded = false;
										foregroundPanel.HScrollValue = (int)Math.Max(0, Math.Min(foregroundPanel.HScrollMaximum, (x * 128)
											+ (128 / 2) - ((foregroundPanel.PanelWidth / 2) / ZoomLevel)));
										foregroundPanel.VScrollValue = (int)Math.Max(0, Math.Min(foregroundPanel.VScrollMaximum, (y * 128)
											+ (128 / 2) - ((foregroundPanel.PanelHeight / 2) / ZoomLevel)));
										loaded = true;
										DrawLevel();
										return;
									}
							MessageBox.Show(this, "No matching chunks found.", "SonLVL-RSDK");
							lastfoundfgchunk = null;
							findNextToolStripMenuItem.Enabled = findPreviousToolStripMenuItem.Enabled = false;
							break;
					}
					break;
				case Tab.Background:
					switch (findBGChunksDialog.ShowDialog(this))
					{
						case DialogResult.Yes:
							int count = 0;
							for (int x = 0; x < LevelData.BGWidth[bglayer]; x++)
								for (int y = 0; y < LevelData.BGHeight[bglayer]; y++)
									if (LevelData.Background.layers[bglayer].layout[y][x] == findBGChunksDialog.chunkSelect.Value)
										count++;
							MessageBox.Show(this, count + " chunk" + (count != 1 ? "s" : "") + " found.",
								"SonLVL-RSDK");
							break;
						case DialogResult.OK:
							for (int x = 0; x < LevelData.BGWidth[bglayer]; x++)
								for (int y = 0; y < LevelData.BGHeight[bglayer]; y++)
									if (LevelData.Background.layers[bglayer].layout[y][x] == findBGChunksDialog.chunkSelect.Value)
									{
										lastfoundbgchunk = new Point(x, y);
										searchbgchunk = (byte)findBGChunksDialog.chunkSelect.Value;
										findNextToolStripMenuItem.Enabled = true;
										findPreviousToolStripMenuItem.Enabled = false;
										BGSelection = new Rectangle(x, y, 1, 1);
										loaded = false;
										backgroundPanel.HScrollValue = (int)Math.Max(0, Math.Min(backgroundPanel.HScrollMaximum, (x * 128)
											+ (128 / 2) - ((backgroundPanel.PanelWidth / 2) / ZoomLevel)));
										backgroundPanel.VScrollValue = (int)Math.Max(0, Math.Min(backgroundPanel.VScrollMaximum, (y * 128)
											+ (128 / 2) - ((backgroundPanel.PanelHeight / 2) / ZoomLevel)));
										loaded = true;
										DrawLevel();
										return;
									}
							MessageBox.Show(this, "No matching chunks found.", "SonLVL-RSDK");
							lastfoundbgchunk = null;
							findNextToolStripMenuItem.Enabled = findPreviousToolStripMenuItem.Enabled = false;
							break;
					}
					break;
			}
		}

		private void ScrollToObject(Entry item)
		{
			loaded = false;
			objectPanel.HScrollValue = (int)Math.Max(0, Math.Min(objectPanel.HScrollMaximum, item.X - ((objectPanel.PanelWidth / 2) / ZoomLevel)));
			objectPanel.VScrollValue = (int)Math.Max(0, Math.Min(objectPanel.VScrollMaximum, item.Y - ((objectPanel.PanelHeight / 2) / ZoomLevel)));
			loaded = true;
		}

		private void findNextToolStripMenuItem_Click(object sender, EventArgs e)
		{
			switch (CurrentTab)
			{
				case Tab.Objects:
					if (lastfoundobj < foundobjs.Count - 1)
					{
						SelectedItems.Clear();
						SelectedItems.Add(foundobjs[++lastfoundobj]);
						ScrollToObject(SelectedItems[0]);
						findPreviousToolStripMenuItem.Enabled = true;
						SelectedObjectChanged();
						DrawLevel();
					}
					else
					{
						MessageBox.Show(this, "No more objects found.", "SonLVL-RSDK");
						findNextToolStripMenuItem.Enabled = false;
					}
					break;
				case Tab.Foreground:
					for (int x = 0; x < LevelData.FGWidth; x++)
						for (int y = 0; y < LevelData.FGHeight; y++)
						{
							if (x == 0 && y == 0)
							{
								x = lastfoundfgchunk.Value.X;
								y = lastfoundfgchunk.Value.Y;
							}
							else if (LevelData.Scene.layout[y][x] == searchfgchunk)
							{
								lastfoundfgchunk = new Point(x, y);
								findPreviousToolStripMenuItem.Enabled = true;
								FGSelection = new Rectangle(x, y, 1, 1);
								loaded = false;
								foregroundPanel.HScrollValue = (int)Math.Max(0, Math.Min(foregroundPanel.HScrollMaximum, (x * 128)
									+ (128 / 2) - ((foregroundPanel.PanelWidth / 2) / ZoomLevel)));
								foregroundPanel.VScrollValue = (int)Math.Max(0, Math.Min(foregroundPanel.VScrollMaximum, (y * 128)
									+ (128 / 2) - ((foregroundPanel.PanelHeight / 2) / ZoomLevel)));
								loaded = true;
								DrawLevel();
								return;
							}
						}
					MessageBox.Show(this, "No more chunks found.", "SonLVL-RSDK");
					findNextToolStripMenuItem.Enabled = false;
					break;
				case Tab.Background:
					for (int x = 0; x < LevelData.BGWidth[bglayer]; x++)
						for (int y = 0; y < LevelData.BGHeight[bglayer]; y++)
						{
							if (x == 0 && y == 0)
							{
								x = lastfoundbgchunk.Value.X;
								y = lastfoundbgchunk.Value.Y;
							}
							else if (LevelData.Background.layers[bglayer].layout[y][x] == searchbgchunk)
							{
								lastfoundbgchunk = new Point(x, y);
								findPreviousToolStripMenuItem.Enabled = true;
								BGSelection = new Rectangle(x, y, 1, 1);
								loaded = false;
								backgroundPanel.HScrollValue = (int)Math.Max(0, Math.Min(backgroundPanel.HScrollMaximum, (x * 128)
									+ (128 / 2) - ((backgroundPanel.PanelWidth / 2) / ZoomLevel)));
								backgroundPanel.VScrollValue = (int)Math.Max(0, Math.Min(backgroundPanel.VScrollMaximum, (y * 128)
									+ (128 / 2) - ((backgroundPanel.PanelHeight / 2) / ZoomLevel)));
								loaded = true;
								DrawLevel();
								return;
							}
						}
					MessageBox.Show(this, "No more chunks found.", "SonLVL-RSDK");
					findNextToolStripMenuItem.Enabled = false;
					break;
			}
		}

		private void findPreviousToolStripMenuItem_Click(object sender, EventArgs e)
		{
			switch (CurrentTab)
			{
				case Tab.Objects:
					if (lastfoundobj > 0)
					{
						SelectedItems.Clear();
						SelectedItems.Add(foundobjs[--lastfoundobj]);
						ScrollToObject(SelectedItems[0]);
						findNextToolStripMenuItem.Enabled = true;
						SelectedObjectChanged();
						DrawLevel();
					}
					else
					{
						MessageBox.Show(this, "No more objects found.", "SonLVL-RSDK");
						findPreviousToolStripMenuItem.Enabled = false;
					}
					break;
				case Tab.Foreground:
					for (int x = (LevelData.FGWidth - 1); x >= 0; x--)
						for (int y = (LevelData.FGHeight - 1); y >= 0; y--)
						{
							if (x == (LevelData.FGWidth - 1) && y == (LevelData.FGHeight - 1))
							{
								x = lastfoundfgchunk.Value.X;
								y = lastfoundfgchunk.Value.Y;
							}
							else if (LevelData.Scene.layout[y][x] == searchfgchunk)
							{
								lastfoundfgchunk = new Point(x, y);
								findNextToolStripMenuItem.Enabled = true;
								FGSelection = new Rectangle(x, y, 1, 1);
								loaded = false;
								foregroundPanel.HScrollValue = (int)Math.Max(0, Math.Min(foregroundPanel.HScrollMaximum, (x * 128)
									+ (128 / 2) - ((foregroundPanel.PanelWidth / 2) / ZoomLevel)));
								foregroundPanel.VScrollValue = (int)Math.Max(0, Math.Min(foregroundPanel.VScrollMaximum, (y * 128)
									+ (128 / 2) - ((foregroundPanel.PanelHeight / 2) / ZoomLevel)));
								loaded = true;
								DrawLevel();
								return;
							}
						}
					MessageBox.Show(this, "No more chunks found.", "SonLVL-RSDK");
					findPreviousToolStripMenuItem.Enabled = false;
					break;
				case Tab.Background:
					for (int x = (LevelData.BGWidth[bglayer] - 1); x >= 0; x--)
						for (int y = (LevelData.BGHeight[bglayer] - 1); y >= 0; y--)
						{
							if (x == (LevelData.BGWidth[bglayer] - 1) && y == (LevelData.BGHeight[bglayer] - 1))
							{
								x = lastfoundbgchunk.Value.X;
								y = lastfoundbgchunk.Value.Y;
							}
							else if (LevelData.Background.layers[bglayer].layout[y][x] == searchbgchunk)
							{
								lastfoundbgchunk = new Point(x, y);
								findNextToolStripMenuItem.Enabled = true;
								BGSelection = new Rectangle(x, y, 1, 1);
								loaded = false;
								backgroundPanel.HScrollValue = (int)Math.Max(0, Math.Min(backgroundPanel.HScrollMaximum, (x * 128)
									+ (128 / 2) - ((backgroundPanel.PanelWidth / 2) / ZoomLevel)));
								backgroundPanel.VScrollValue = (int)Math.Max(0, Math.Min(backgroundPanel.VScrollMaximum, (y * 128)
									+ (128 / 2) - ((backgroundPanel.PanelHeight / 2) / ZoomLevel)));
								loaded = true;
								DrawLevel();
								return;
							}
						}
					MessageBox.Show(this, "No more chunks found.", "SonLVL-RSDK");
					findPreviousToolStripMenuItem.Enabled = false;
					break;
			}
		}

		private void objectsAboveHighPlaneToolStripMenuItem_CheckedChanged(object sender, EventArgs e)
		{
			Settings.ObjectsAboveHighPlane = objectsAboveHighPlaneToolStripMenuItem.Checked;
		}

		private void lowToolStripMenuItem_CheckedChanged(object sender, EventArgs e)
		{
			Settings.ViewLowPlane = lowToolStripMenuItem.Checked;
		}

		private void highToolStripMenuItem_CheckedChanged(object sender, EventArgs e)
		{
			Settings.ViewHighPlane = highToolStripMenuItem.Checked;
		}

		private void objGridSizeDropDownButton_DropDownItemClicked(object sender, ToolStripItemClickedEventArgs e)
		{
			foreach (ToolStripMenuItem item in objGridSizeDropDownButton.DropDownItems)
				item.Checked = false;
			((ToolStripMenuItem)e.ClickedItem).Checked = true;
			objGridSizeDropDownButton.Text = "Grid Size: " + (1 << (ObjGrid = (byte)objGridSizeDropDownButton.DropDownItems.IndexOf(e.ClickedItem)));
			if (!loaded) return;
			DrawLevel();
		}

		private void ChunkSelector_ItemDrag(object sender, EventArgs e)
		{
			if (CurrentTab == Tab.Art && enableDraggingChunksButton.Checked)
				DoDragDrop(new DataObject("SonLVLChunkIndex_" + pid, ChunkSelector.SelectedIndex), DragDropEffects.Move);
		}

		bool chunk_dragdrop;
		int chunk_dragobj;
		Point chunk_dragpoint;
		private void ChunkSelector_DragEnter(object sender, DragEventArgs e)
		{
			if (e.Data.GetDataPresent("SonLVLChunkIndex_" + pid))
			{
				e.Effect = DragDropEffects.Move;
				chunk_dragdrop = true;
				chunk_dragobj = (int)e.Data.GetData("SonLVLChunkIndex_" + pid);
				chunk_dragpoint = ChunkSelector.PointToClient(new Point(e.X, e.Y));
				ChunkSelector.Invalidate();
			}
			else
				chunk_dragdrop = false;
		}

		private void ChunkSelector_DragOver(object sender, DragEventArgs e)
		{
			if (e.Data.GetDataPresent("SonLVLChunkIndex_" + pid))
			{
				e.Effect = DragDropEffects.Move;
				chunk_dragdrop = true;
				chunk_dragobj = (int)e.Data.GetData("SonLVLChunkIndex_" + pid);
				chunk_dragpoint = ChunkSelector.PointToClient(new Point(e.X, e.Y));
				if (chunk_dragpoint.Y < 8)
					ChunkSelector.ScrollValue -= 8 - dragpoint.Y;
				else if (dragpoint.Y > ChunkSelector.Height - 8)
					ChunkSelector.ScrollValue += dragpoint.Y - (ChunkSelector.Height - 8);
				ChunkSelector.Invalidate();
			}
			else
				chunk_dragdrop = false;
		}

		private void ChunkSelector_DragLeave(object sender, EventArgs e)
		{
			chunk_dragdrop = false;
			ChunkSelector.Invalidate();
		}

		private void ChunkSelector_Paint(object sender, PaintEventArgs e)
		{
			if (chunk_dragdrop)
			{
				e.Graphics.DrawImage(ChunkSelector.Images[chunk_dragobj], chunk_dragpoint.X - (ChunkSelector.ImageWidth / 2),
					chunk_dragpoint.Y - (ChunkSelector.ImageHeight / 2), ChunkSelector.ImageWidth, ChunkSelector.ImageHeight);
				Rectangle r = ChunkSelector.GetItemBounds(ChunkSelector.GetItemAtPoint(chunk_dragpoint));
				if ((ModifierKeys & Keys.Control) == Keys.Control)
					e.Graphics.DrawRectangle(new Pen(Color.Black, 2), r);
				else
					e.Graphics.DrawLine(new Pen(Color.Black, 2), r.Left + 1, r.Top, r.Left + 1, r.Bottom);
			}
		}

		private void ChunkSelector_DragDrop(object sender, DragEventArgs e)
		{
			chunk_dragdrop = false;
			if (e.Data.GetDataPresent("SonLVLChunkIndex_" + pid))
			{
				Point clientPoint = ChunkSelector.PointToClient(new Point(e.X, e.Y));
				byte newindex = (byte)ChunkSelector.GetItemAtPoint(clientPoint);
				byte oldindex = (byte)(int)e.Data.GetData("SonLVLChunkIndex_" + pid);
				if (newindex == oldindex) return;
				if ((ModifierKeys & Keys.Control) == Keys.Control)
				{
					if (newindex == LevelData.NewChunks.chunkList.Length) return;
					LevelData.NewChunks.chunkList.Swap(oldindex, newindex);
					LevelData.ChunkSprites.Swap(oldindex, newindex);
					LevelData.ChunkBmps.Swap(oldindex, newindex);
					LevelData.ChunkColBmpBits.Swap(oldindex, newindex);
					LevelData.ChunkColBmps.Swap(oldindex, newindex);
					LevelData.CompChunkBmps.Swap(oldindex, newindex);
					LevelData.RemapLayouts((layout, x, y) =>
					{
						if (layout[y][x] == newindex)
							layout[y][x] = oldindex;
						else if (layout[y][x] == oldindex)
							layout[y][x] = newindex;
					});
					ChunkSelector.SelectedIndex = newindex;
				}
				else
				{
					if (newindex == oldindex + 1) return;
					LevelData.NewChunks.chunkList.Move(oldindex, newindex);
					LevelData.ChunkSprites.Move(oldindex, newindex);
					LevelData.ChunkBmps.Move(oldindex, newindex);
					LevelData.ChunkColBmpBits.Move(oldindex, newindex);
					LevelData.ChunkColBmps.Move(oldindex, newindex);
					LevelData.CompChunkBmps.Move(oldindex, newindex);
					LevelData.RemapLayouts((layout, x, y) =>
					{
						ushort c = layout[y][x];
						if (newindex > oldindex)
						{
							if (c == oldindex)
								layout[y][x] = (byte)(newindex - 1);
							else if (c > oldindex && c < newindex)
								layout[y][x] = (byte)(c - 1);
						}
						else
						{
							if (c == oldindex)
								layout[y][x] = newindex;
							else if (c >= newindex && c < oldindex)
								layout[y][x] = (byte)(c + 1);
						}
					});
					if (newindex > oldindex)
						ChunkSelector.SelectedIndex = newindex - 1;
					else
						ChunkSelector.SelectedIndex = newindex;
				}
			}
		}

		private void TileSelector_ItemDrag(object sender, EventArgs e)
		{
			if (enableDraggingTilesButton.Checked)
				DoDragDrop(new DataObject("SonLVLTileIndex_" + pid, TileSelector.SelectedIndex), DragDropEffects.Move);
		}

		bool tile_dragdrop;
		int tile_dragobj;
		Point tile_dragpoint;
		private void TileSelector_DragEnter(object sender, DragEventArgs e)
		{
			if (e.Data.GetDataPresent("SonLVLTileIndex_" + pid))
			{
				e.Effect = DragDropEffects.Move;
				tile_dragdrop = true;
				tile_dragobj = (int)e.Data.GetData("SonLVLTileIndex_" + pid);
				tile_dragpoint = TileSelector.PointToClient(new Point(e.X, e.Y));
				TileSelector.Invalidate();
			}
			else
				tile_dragdrop = false;
		}

		private void TileSelector_DragOver(object sender, DragEventArgs e)
		{
			if (e.Data.GetDataPresent("SonLVLTileIndex_" + pid))
			{
				e.Effect = DragDropEffects.Move;
				tile_dragdrop = true;
				tile_dragobj = (int)e.Data.GetData("SonLVLTileIndex_" + pid);
				tile_dragpoint = TileSelector.PointToClient(new Point(e.X, e.Y));
				if (tile_dragpoint.Y < 8)
					TileSelector.ScrollValue -= 8 - dragpoint.Y;
				else if (dragpoint.Y > TileSelector.Height - 8)
					TileSelector.ScrollValue += dragpoint.Y - (TileSelector.Height - 8);
				TileSelector.Invalidate();
			}
			else
				tile_dragdrop = false;
		}

		private void TileSelector_DragLeave(object sender, EventArgs e)
		{
			tile_dragdrop = false;
			TileSelector.Invalidate();
		}

		private void TileSelector_Paint(object sender, PaintEventArgs e)
		{
			if (tile_dragdrop)
			{
				e.Graphics.DrawImage(TileSelector.Images[tile_dragobj], tile_dragpoint.X - (TileSelector.ImageWidth / 2),
					tile_dragpoint.Y - (TileSelector.ImageHeight / 2), TileSelector.ImageWidth, TileSelector.ImageHeight);
				Rectangle r = TileSelector.GetItemBounds(TileSelector.GetItemAtPoint(tile_dragpoint));
				if ((ModifierKeys & Keys.Control) == Keys.Control)
					e.Graphics.DrawRectangle(new Pen(Color.Black, 2), r);
				else
					e.Graphics.DrawLine(new Pen(Color.Black, 2), r.Left + 1, r.Top, r.Left + 1, r.Bottom);
			}
		}

		private void TileSelector_DragDrop(object sender, DragEventArgs e)
		{
			tile_dragdrop = false;
			if (e.Data.GetDataPresent("SonLVLTileIndex_" + pid))
			{
				Point clientPoint = TileSelector.PointToClient(new Point(e.X, e.Y));
				ushort newindex = (ushort)TileSelector.GetItemAtPoint(clientPoint);
				ushort oldindex = (ushort)(int)e.Data.GetData("SonLVLTileIndex_" + pid);
				if (newindex == oldindex) return;
				if ((ModifierKeys & Keys.Control) == Keys.Control)
				{
					if (newindex == TileSelector.Images.Count) return;
					LevelData.NewTiles.Swap(oldindex, newindex);
					LevelData.NewTileBmps.Swap(oldindex, newindex);
					LevelData.Collision.collisionMasks[0].Swap(oldindex, newindex);
					LevelData.Collision.collisionMasks[1].Swap(oldindex, newindex);
					LevelData.NewColBmpBits.Swap(oldindex, newindex);
					LevelData.NewColBmps.Swap(oldindex, newindex);
					for (int i = 0; i < LevelData.NewChunks.chunkList.Length; i++)
						for (int y = 0; y < 8; y++)
							for (int x = 0; x < 8; x++)
							{
								if (LevelData.NewChunks.chunkList[i].tiles[y][x].tileIndex == newindex)
									LevelData.NewChunks.chunkList[i].tiles[y][x].tileIndex = oldindex;
								else if (LevelData.NewChunks.chunkList[i].tiles[y][x].tileIndex == oldindex)
									LevelData.NewChunks.chunkList[i].tiles[y][x].tileIndex = newindex;
							}
					TileSelector.SelectedIndex = newindex;
				}
				else
				{
					if (newindex == oldindex + 1) return;
					if (newindex > oldindex) --newindex;
					LevelData.NewTiles.Move(oldindex, newindex);
					LevelData.NewTileBmps.Move(oldindex, newindex);
					LevelData.Collision.collisionMasks[0].Move(oldindex, newindex);
					LevelData.Collision.collisionMasks[1].Move(oldindex, newindex);
					LevelData.NewColBmpBits.Move(oldindex, newindex);
					LevelData.NewColBmps.Move(oldindex, newindex);
					for (int i = 0; i < LevelData.NewChunks.chunkList.Length; i++)
						for (int y = 0; y < 8; y++)
							for (int x = 0; x < 8; x++)
							{
								ushort t = LevelData.NewChunks.chunkList[i].tiles[y][x].tileIndex;
								if (newindex > oldindex)
								{
									if (t == oldindex)
										LevelData.NewChunks.chunkList[i].tiles[y][x].tileIndex = newindex;
									else if (t > oldindex && t <= newindex)
										LevelData.NewChunks.chunkList[i].tiles[y][x].tileIndex = (ushort)(t - 1);
								}
								else
								{
									if (t == oldindex)
										LevelData.NewChunks.chunkList[i].tiles[y][x].tileIndex = newindex;
									else if (t >= newindex && t < oldindex)
										LevelData.NewChunks.chunkList[i].tiles[y][x].tileIndex = (ushort)(t + 1);
								}
							}
					TileSelector.SelectedIndex = newindex;
				}
			}
		}

		private void remapChunksButton_Click(object sender, EventArgs e)
		{
			using (TileRemappingDialog dlg = new TileRemappingDialog("Chunks", LevelData.CompChunkBmps, 128, 128))
				if (dlg.ShowDialog(this) == DialogResult.OK)
				{
					List<RSDKv3_4.Tiles128x128.Block> oldchunks = LevelData.NewChunks.chunkList.ToList();
					List<Sprite> oldchunkbmpbits = new List<Sprite>(LevelData.ChunkSprites);
					List<Bitmap[]> oldchunkbmps = new List<Bitmap[]>(LevelData.ChunkBmps);
					List<BitmapBits[]> oldchunkcolbmpbits = new List<BitmapBits[]>(LevelData.ChunkColBmpBits);
					List<Bitmap[]> oldchunkcolbmps = new List<Bitmap[]>(LevelData.ChunkColBmps);
					List<Bitmap> oldcompchunkbmps = new List<Bitmap>(LevelData.CompChunkBmps);
					Dictionary<ushort, ushort> bytedict = new Dictionary<ushort, ushort>(dlg.TileMap.Count);
					foreach (KeyValuePair<int, int> item in dlg.TileMap)
					{
						LevelData.NewChunks.chunkList[item.Value] = oldchunks[item.Key];
						LevelData.ChunkSprites[item.Value] = oldchunkbmpbits[item.Key];
						LevelData.ChunkBmps[item.Value] = oldchunkbmps[item.Key];
						LevelData.ChunkColBmpBits[item.Value] = oldchunkcolbmpbits[item.Key];
						LevelData.ChunkColBmps[item.Value] = oldchunkcolbmps[item.Key];
						LevelData.CompChunkBmps[item.Value] = oldcompchunkbmps[item.Key];
						bytedict.Add((ushort)item.Key, (ushort)item.Value);
					}
					LevelData.RemapLayouts((layout, x, y) =>
					{
						if (bytedict.ContainsKey(layout[y][x]))
							layout[y][x] = bytedict[layout[y][x]];
					});
					ChunkSelector.ChangeSize();
					ChunkSelector_SelectedIndexChanged(this, EventArgs.Empty);
				}
		}

		private void remapTilesButton_Click(object sender, EventArgs e)
		{
			using (TileRemappingDialog dlg = new TileRemappingDialog("Tiles", TileSelector.Images, TileSelector.ImageWidth, TileSelector.ImageHeight))
				if (dlg.ShowDialog(this) == DialogResult.OK)
				{
					List<BitmapBits> oldtiles = LevelData.NewTiles.ToList();
					List<Bitmap> oldimages = new List<Bitmap>(LevelData.NewTileBmps);
					List<RSDKv3_4.TileConfig.CollisionMask> oldmasks1 = new List<RSDKv3_4.TileConfig.CollisionMask>(LevelData.Collision.collisionMasks[0]);
					List<RSDKv3_4.TileConfig.CollisionMask> oldmasks2 = new List<RSDKv3_4.TileConfig.CollisionMask>(LevelData.Collision.collisionMasks[1]);
					List<BitmapBits[]> oldcolbmpbits = new List<BitmapBits[]>(LevelData.NewColBmpBits);
					List<Bitmap[]> oldcolbmps = new List<Bitmap[]>(LevelData.NewColBmps);
					Dictionary<ushort, ushort> ushortdict = new Dictionary<ushort, ushort>(dlg.TileMap.Count);
					foreach (KeyValuePair<int, int> item in dlg.TileMap)
					{
						LevelData.NewTiles[item.Value] = oldtiles[item.Key];
						LevelData.NewTileBmps[item.Value] = oldimages[item.Key];
						LevelData.Collision.collisionMasks[0][item.Value] = oldmasks1[item.Key];
						LevelData.Collision.collisionMasks[1][item.Value] = oldmasks2[item.Key];
						LevelData.NewColBmpBits[item.Value] = oldcolbmpbits[item.Key];
						LevelData.NewColBmps[item.Value] = oldcolbmps[item.Key];
						ushortdict.Add((ushort)item.Key, (ushort)item.Value);
					}
					for (int b = 0; b < LevelData.NewChunks.chunkList.Length; b++)
					{
						bool redraw = false;
						for (int y = 0; y < 8; y++)
							for (int x = 0; x < 8; x++)
								if (ushortdict.ContainsKey(LevelData.NewChunks.chunkList[b].tiles[y][x].tileIndex))
								{
									redraw = true;
									LevelData.NewChunks.chunkList[b].tiles[y][x].tileIndex = ushortdict[LevelData.NewChunks.chunkList[b].tiles[y][x].tileIndex];
								}
						if (redraw)
							LevelData.RedrawChunk(b);
					}
					TileSelector.ChangeSize();
					TileSelector_SelectedIndexChanged(this, EventArgs.Empty);
				}
		}

		private void saveSectionToolStripMenuItem_Click(object sender, EventArgs e)
		{
			using (LayoutSectionNameDialog dlg = new LayoutSectionNameDialog())
			{
				dlg.Value = "Section " + (savedLayoutSections.Count + 1);
				if (dlg.ShowDialog(this) == DialogResult.OK)
				{
					LayoutSection sec = CreateLayoutSection();
					sec.Name = dlg.Value;
					savedLayoutSections.Add(sec);
					savedLayoutSectionImages.Add(MakeLayoutSectionImage(sec));
					layoutSectionListBox.Items.Add(sec.Name);
					layoutSectionListBox.SelectedIndex = savedLayoutSections.Count - 1;
					string levelname = this.levelname;
					foreach (char c in Path.GetInvalidFileNameChars())
						levelname = levelname.Replace(c, '_');
					using (FileStream fs = File.Create(levelname + ".sls"))
						new BinaryFormatter().Serialize(fs, savedLayoutSections);
				}
			}
		}

		private void layoutSectionListBox_SelectedIndexChanged(object sender, EventArgs e)
		{
			if (layoutSectionListBox.SelectedIndex == -1)
				layoutSectionPreview.Image = null;
			else
				layoutSectionPreview.Image = savedLayoutSectionImages[layoutSectionListBox.SelectedIndex];
		}

		private void layoutSectionListBox_KeyDown(object sender, KeyEventArgs e)
		{
			if (layoutSectionListBox.SelectedIndex != -1 && e.KeyCode == Keys.Delete
				&& MessageBox.Show(this, "Are you sure you want to delete layout section \"" + savedLayoutSections[layoutSectionListBox.SelectedIndex].Name + "\"?", "SonLVL-RSDK", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning) == DialogResult.OK)
			{
				savedLayoutSections.RemoveAt(layoutSectionListBox.SelectedIndex);
				savedLayoutSectionImages.RemoveAt(layoutSectionListBox.SelectedIndex);
				layoutSectionListBox.Items.RemoveAt(layoutSectionListBox.SelectedIndex);
				string levelname = this.levelname;
				foreach (char c in Path.GetInvalidFileNameChars())
					levelname = levelname.Replace(c, '_');
				using (FileStream fs = File.Create(levelname + ".sls"))
					new BinaryFormatter().Serialize(fs, savedLayoutSections);
			}
		}

		private void pasteSectionOnceToolStripMenuItem_Click(object sender, EventArgs e)
		{
			PasteLayoutSectionOnce(savedLayoutSections[layoutSectionListBox.SelectedIndex]);
		}

		private void pasteSectionRepeatingToolStripMenuItem_Click(object sender, EventArgs e)
		{
			PasteLayoutSectionRepeating(savedLayoutSections[layoutSectionListBox.SelectedIndex]);
		}

		private void deepCopyToolStripMenuItem_Click(object sender, EventArgs e)
		{
			switch (CurrentArtTab)
			{
				case ArtTab.Chunks:
					Clipboard.SetData(typeof(ChunkCopyData).AssemblyQualifiedName, new ChunkCopyData(LevelData.NewChunks.chunkList[SelectedChunk]));
					break;
			}
		}

		private void flipTileHButton_Click(object sender, EventArgs e)
		{
			LevelData.NewTiles[SelectedTile].Flip(true, false);
			LevelData.RedrawBlock(SelectedTile, true);
			chunkBlockEditor.SelectedObjects = chunkBlockEditor.SelectedObjects;
			DrawTilePicture();
			TileSelector.Invalidate();
		}

		private void flipTileVButton_Click(object sender, EventArgs e)
		{
			LevelData.NewTiles[SelectedTile].Flip(false, true);
			LevelData.RedrawBlock(SelectedTile, true);
			chunkBlockEditor.SelectedObjects = chunkBlockEditor.SelectedObjects;
			DrawTilePicture();
			TileSelector.Invalidate();
		}

		private void showBlockBehindCollisionCheckBox_CheckedChanged(object sender, EventArgs e)
		{
			DrawColPicture();
		}

		private void pasteOverToolStripMenuItem_Click(object sender, EventArgs e)
		{
			switch (CurrentArtTab)
			{
				case ArtTab.Chunks:
					if (Clipboard.ContainsData(typeof(ChunkCopyData).AssemblyQualifiedName))
					{
						ChunkCopyData cnkcpy = (ChunkCopyData)Clipboard.GetData(typeof(ChunkCopyData).AssemblyQualifiedName);
						if (cnkcpy.Tiles.Count > LevelData.GetFreeTiles().Count())
						{
							MessageBox.Show(this, "Level does not have enough free tiles.", Text, MessageBoxButtons.OK, MessageBoxIcon.Warning);
							return;
						}
						List<ushort> tiles = new List<ushort>(cnkcpy.Tiles.Count);
						foreach (BitmapBits tile in cnkcpy.Tiles)
						{
							ushort ti = (ushort)LevelData.NewTiles.Length;
							for (ushort j = 0; j < LevelData.NewTiles.Length; j++)
								if (tile.FastArrayEqual(LevelData.NewTiles[j]))
								{
									ti = j;
									break;
								}
							if (ti == LevelData.NewTiles.Length)
								LevelData.Tiles.Add(tile);
							tiles.Add(ti);
						}
						LevelData.UpdateTileArray();
						TileID.Maximum = LevelData.NewTiles.Length - 1;
						RefreshTileSelector();
						//blockTileEditor.SelectedObjects = blockTileEditor.SelectedObjects;
						List<ushort> blocks = new List<ushort>(cnkcpy.Blocks.Count);
						for (int i = 0; i < cnkcpy.Blocks.Count; i++)
						{
							Block block = cnkcpy.Blocks[i];
							for (int y = 0; y < 2; y++)
								for (int x = 0; x < 2; x++)
									block.Tiles[x, y].Tile = tiles[block.Tiles[x, y].Tile];
							ushort bi = (ushort)LevelData.NewTiles.Length;
							for (ushort j = 0; j < LevelData.NewTiles.Length; j++)
								if (block.Equals(LevelData.NewTiles[j]))
								{
									bi = j;
									break;
								}
							if (bi == LevelData.NewTiles.Length)
							{
								LevelData.NewTiles.Add(block);
								LevelData.ColInds1.AddOrSet(bi, cnkcpy.ColInds1[i]);
								if (LevelData.ColInds2 != null && LevelData.ColInds2 != LevelData.ColInds1)
									LevelData.ColInds2.AddOrSet(bi, cnkcpy.ColInds2?[i] ?? cnkcpy.ColInds1[i]);
								LevelData.BlockBmps.Add(new Bitmap[2]);
								LevelData.BlockBmpBits.Add(new BitmapBits[2]);
								LevelData.CompBlockBmps.Add(null);
								LevelData.CompBlockBmpBits.Add(null);
								LevelData.RedrawBlock(bi, false);
							}
							blocks.Add(bi);
						}
						//BlockID.Maximum = LevelData.NewTiles.Length - 1;
						for (int y = 0; y < 128 / 16; y++)
							for (int x = 0; x < 128 / 16; x++)
								cnkcpy.Chunk.tiles[y][x].tileIndex = blocks[cnkcpy.Chunk.tiles[y][x].tileIndex];
						LevelData.NewChunks.chunkList[SelectedChunk] = cnkcpy.Chunk;
					}
					else
						LevelData.NewChunks.chunkList[SelectedChunk] = new Chunk((byte[])Clipboard.GetData(typeof(Chunk).AssemblyQualifiedName), 0);
					LevelData.RedrawChunk(SelectedChunk);
					break;
				case ArtTab.Tiles:
					if (LevelData.Level.TwoPlayerCompatible)
					{
						byte[][] t = (byte[][])Clipboard.GetData("SonLVLTileInterlaced");
						LevelData.Tiles[SelectedTile] = t[0];
						LevelData.Tiles[SelectedTile + 1] = t[1];
						t[0].CopyTo(LevelData.TileArray, SelectedTile * 32);
						t[1].CopyTo(LevelData.TileArray, SelectedTile * 32 + 32);
					}
					else
					{
						byte[] t = (byte[])Clipboard.GetData("SonLVLTile");
						LevelData.Tiles[SelectedTile] = t;
						t.CopyTo(LevelData.TileArray, SelectedTile * 32);
					}
					for (int i = 0; i < LevelData.NewTiles.Length; i++)
					{
						bool dr = false;
						for (int y = 0; y < 2; y++)
							for (int x = 0; x < 2; x++)
								if (LevelData.NewTiles[i].Tiles[x, y].Tile == SelectedTile)
									dr = true;
						if (dr)
							LevelData.RedrawBlock(i, true);
					}
					if (LevelData.Level.TwoPlayerCompatible)
						TileSelector.Images[SelectedTile / 2] = LevelData.InterlacedTileToBmp4bpp(LevelData.TileArray, SelectedTile, SelectedColor.Y);
					else
						TileSelector.Images[SelectedTile] = LevelData.TileToBmp4bpp(LevelData.Tiles[SelectedTile], 0, SelectedColor.Y, false);
					chunkBlockEditor.SelectedObjects = chunkBlockEditor.SelectedObjects;
					break;
			}
		}

		private ColInfo[][,] ProcessColBmps(Bitmap colbmp1, Bitmap colbmp2, int w, int h)
		{
			ColInfo[,] coldata1;
			ColInfo[,] coldata2 = null;
			using (colbmp1)
			using (Bitmap tmp = new Bitmap(w, h))
			using (Graphics g = Graphics.FromImage(tmp))
			{
				g.SetOptions();
				g.DrawImage(colbmp1, 0, 0, colbmp1.Width, colbmp1.Height);
				coldata1 = LevelData.GetColMap(tmp);
			}
			Application.DoEvents();
			if (colbmp2 != null)
				using (colbmp2)
				using (Bitmap tmp = new Bitmap(w, h))
				using (Graphics g = Graphics.FromImage(tmp))
				{
					g.SetOptions();
					g.DrawImage(colbmp2, 0, 0, colbmp2.Width, colbmp2.Height);
					coldata2 = LevelData.GetColMap(tmp);
					Application.DoEvents();
				}
			return new ColInfo[2][,] { coldata1, coldata2 };
		}

		private void importToolStripMenuItem2_Click(object sender, EventArgs e)
		{
			using (OpenFileDialog opendlg = new OpenFileDialog()
			{
				DefaultExt = "png",
				Filter = "Image Files|*.bmp;*.png;*.jpg;*.gif",
				RestoreDirectory = true
			})
				if (opendlg.ShowDialog(this) == DialogResult.OK)
					using (Bitmap bmp = new Bitmap(opendlg.FileName))
					{
						if (bmp.Width < 128 || bmp.Height < 128)
						{
							MessageBox.Show(this, $"The image you have selected is too small ({bmp.Width}x{bmp.Height}). It must be at least as large as one chunk (128x128)", "SonLVL-RSDK Layout Importer", MessageBoxButtons.OK, MessageBoxIcon.Warning);
							return;
						}
						Bitmap colbmp1 = null, colbmp2 = null, pribmp = null;
						string fmt = Path.Combine(Path.GetDirectoryName(opendlg.FileName),
							Path.GetFileNameWithoutExtension(opendlg.FileName) + "_{0}" + Path.GetExtension(opendlg.FileName));
						if (File.Exists(string.Format(fmt, "col1")))
						{
							colbmp1 = new Bitmap(string.Format(fmt, "col1"));
							if (File.Exists(string.Format(fmt, "col2")))
								colbmp2 = new Bitmap(string.Format(fmt, "col2"));
						}
						else if (File.Exists(string.Format(fmt, "col")))
							colbmp1 = new Bitmap(string.Format(fmt, "col"));
						if (File.Exists(string.Format(fmt, "pri")))
							pribmp = new Bitmap(string.Format(fmt, "pri"));
						ushort[,] section = new ushort[bmp.Width / 128, bmp.Height / 128];
						if (!ImportImage(bmp, colbmp1, colbmp2, pribmp, section))
							return;
						ushort[,] layout;
						bool[,] loop;
						int w, h;
						if (CurrentTab == Tab.Background)
						{
							layout = LevelData.Layout.BGLayout;
							loop = LevelData.Layout.BGLoop;
							w = Math.Min(section.GetLength(0), LevelData.BGWidth - menuLoc.X);
							h = Math.Min(section.GetLength(1), LevelData.BGHeight - menuLoc.Y);
						}
						else
						{
							layout = LevelData.Layout.FGLayout;
							loop = LevelData.Layout.FGLoop;
							w = Math.Min(section.GetLength(0), LevelData.FGWidth - menuLoc.X);
							h = Math.Min(section.GetLength(1), LevelData.FGHeight - menuLoc.Y);
						}
						for (int y = 0; y < h; y++)
							for (int x = 0; x < w; x++)
							{
								layout[y + menuLoc.Y][x + menuLoc.X] = section[x, y];
								if (loop != null)
									loop[x + menuLoc.X, y + menuLoc.Y] = false;
							}
						if (CurrentTab == Tab.Foreground) DoLayoutCopy();
					}
		}

		private void importToolStripButton_Click(object sender, EventArgs e)
		{
			using (OpenFileDialog opendlg = new OpenFileDialog()
			{
				DefaultExt = "png",
				Filter = "Image Files|*.bmp;*.png;*.jpg;*.gif",
				RestoreDirectory = true
			})
				if (opendlg.ShowDialog(this) == DialogResult.OK)
					using (Bitmap bmp = new Bitmap(opendlg.FileName))
					{
						if (bmp.Width < 128 || bmp.Height < 128)
						{
							MessageBox.Show(this, $"The image you have selected is too small ({bmp.Width}x{bmp.Height}). It must be at least as large as one chunk (128x128)", "SonLVL-RSDK Layout Section Importer", MessageBoxButtons.OK, MessageBoxIcon.Warning);
							return;
						}
						Bitmap colbmp1 = null, colbmp2 = null, pribmp = null;
						string fmt = Path.Combine(Path.GetDirectoryName(opendlg.FileName),
							Path.GetFileNameWithoutExtension(opendlg.FileName) + "_{0}" + Path.GetExtension(opendlg.FileName));
						if (File.Exists(string.Format(fmt, "col1")))
						{
							colbmp1 = new Bitmap(string.Format(fmt, "col1"));
							if (File.Exists(string.Format(fmt, "col2")))
								colbmp2 = new Bitmap(string.Format(fmt, "col2"));
						}
						else if (File.Exists(string.Format(fmt, "col")))
							colbmp1 = new Bitmap(string.Format(fmt, "col"));
						if (File.Exists(string.Format(fmt, "pri")))
							pribmp = new Bitmap(string.Format(fmt, "pri"));
						ushort[,] layout = new ushort[bmp.Width / 128, bmp.Height / 128];
						if (!ImportImage(bmp, colbmp1, colbmp2, pribmp, layout))
							return;
						LayoutSection section = new LayoutSection(layout, LevelData.LayoutFormat.HasLoopFlag ? new bool[layout.GetLength(0), layout.GetLength(1)] : null, new List<Entry>());
						using (LayoutSectionNameDialog dlg = new LayoutSectionNameDialog() { Value = Path.GetFileNameWithoutExtension(opendlg.FileName) })
						{
							if (dlg.ShowDialog(this) == DialogResult.OK)
							{
								section.Name = dlg.Value;
								savedLayoutSections.Add(section);
								savedLayoutSectionImages.Add(MakeLayoutSectionImage(section));
								layoutSectionListBox.Items.Add(section.Name);
								layoutSectionListBox.SelectedIndex = savedLayoutSections.Count - 1;
								string levelname = LevelData.Level.DisplayName;
								foreach (char c in Path.GetInvalidFileNameChars())
									levelname = levelname.Replace(c, '_');
								using (FileStream fs = File.Create(levelname + ".sls"))
									new BinaryFormatter().Serialize(fs, savedLayoutSections);
							}
						}
					}
		}

		private void switchMouseButtonsInChunkAndBlockEditorsToolStripMenuItem_CheckedChanged(object sender, EventArgs e)
		{
			if (switchMouseButtonsInChunkAndBlockEditorsToolStripMenuItem.Checked)
			{
				chunkblockMouseDraw = MouseButtons.Right;
				chunkblockMouseSelect = MouseButtons.Left;
				chunkCtrlLabel.Text = "RMB: Paint w/ selected tile\nLMB: Select tile";
			}
			else
			{
				chunkblockMouseDraw = MouseButtons.Left;
				chunkblockMouseSelect = MouseButtons.Right;
				chunkCtrlLabel.Text = "LMB: Paint w/ selected tile\nRMB: Select tile";
			}
			Settings.SwitchChunkBlockMouseButtons = switchMouseButtonsInChunkAndBlockEditorsToolStripMenuItem.Checked;
		}

		private void importProgressControl1_SizeChanged(object sender, EventArgs e)
		{
			importProgressControl1.Location = new Point((ClientSize.Width / 2) - (importProgressControl1.Width / 2), (ClientSize.Height / 2) - (importProgressControl1.Height / 2));
		}

		private void deleteUnusedTilesToolStripButton_Click(object sender, EventArgs e)
		{
			if (MessageBox.Show(this, "Are you sure you want to clear all tiles not used in chunks?", "Delete Unused Tiles", MessageBoxButtons.OKCancel) != DialogResult.OK)
				return;
			int numdel = 0;
			foreach (var i in Enumerable.Range(0, LevelData.NewTiles.Length).Cast<ushort>().Except(LevelData.NewChunks.chunkList.SelectMany(a => a.tiles.SelectMany(b => b).Select(c => c.tileIndex))))
			{
				LevelData.NewTiles[i].Clear();
				LevelData.RedrawBlock(i, false);
				LevelData.Collision.collisionMasks[0][i] = new RSDKv3_4.TileConfig.CollisionMask();
				LevelData.Collision.collisionMasks[1][i] = new RSDKv3_4.TileConfig.CollisionMask();
				++numdel;
			}
			TileSelector.Invalidate();
			chunkBlockEditor.SelectedObjects = chunkBlockEditor.SelectedObjects;
			MessageBox.Show(this, $"Deleted {numdel} unused tiles.", "SonLVL-RSDK");
		}

		private void deleteUnusedChunksToolStripButton_Click(object sender, EventArgs e)
		{
			if (MessageBox.Show(this, "This action may break other levels that share the same chunk set, or levels that alter the level layout dynamically.\n\nAre you sure you want to clear all chunks not used in the layout?", "Delete Unused Chunks", MessageBoxButtons.OKCancel) != DialogResult.OK)
				return;
			int numdel = 0;
			foreach (var i in Enumerable.Range(0, LevelData.NewChunks.chunkList.Length).Cast<ushort>().Except(LevelData.Scene.layout.SelectMany(a => a).Union(LevelData.Background.layers.SelectMany(a => a.layout.SelectMany(b => b)))))
			{
				LevelData.NewChunks.chunkList[i] = new RSDKv3_4.Tiles128x128.Block();
				LevelData.RedrawChunk(i);
			}
			ChunkSelector.Invalidate();
			MessageBox.Show(this, "Deleted " + numdel + " unused chunks.", "SonLVL-RSDK");
		}

		private void clearForegroundToolStripButton_Click(object sender, EventArgs e)
		{
			if (MessageBox.Show(this, "Are you sure you want to clear the foreground layout?", "Clear Foreground", MessageBoxButtons.OKCancel) == DialogResult.OK)
				foreach (var row in LevelData.Scene.layout)
					Array.Clear(row, 0, row.Length);
		}

		private void clearBackgroundToolStripButton_Click(object sender, EventArgs e)
		{
			if (MessageBox.Show(this, "Are you sure you want to clear the background layout?", "Clear Background", MessageBoxButtons.OKCancel) == DialogResult.OK)
				foreach (var row in LevelData.Background.layers[bglayer].layout)
					Array.Clear(row, 0, row.Length);
		}

		private void calculateAngleButton_Click(object sender, EventArgs e)
		{
			floorAngle.Value = LevelData.GetColMap(LevelData.NewColBmps[collisionLayerSelector.SelectedIndex][SelectedTile])[0, 0].Angle; // super lazy
		}

		private void usageCountsToolStripMenuItem_Click(object sender, EventArgs e)
		{
			using (StatisticsDialog dlg = new StatisticsDialog())
				dlg.ShowDialog(this);
		}

		private void replaceForegroundToolStripButton_Click(object sender, EventArgs e)
		{
			if (replaceFGChunksDialog.ShowDialog(this) == DialogResult.OK)
			{
				byte fc = (byte)replaceFGChunksDialog.findChunk.Value;
				byte rc = (byte)replaceFGChunksDialog.replaceChunk.Value;
				int cnt = 0;
				for (int y = 0; y < LevelData.FGHeight; y++)
					for (int x = 0; x < LevelData.FGWidth; x++)
						if (LevelData.Scene.layout[y][x] == fc)
						{
							LevelData.Scene.layout[y][x] = rc;
							cnt++;
						}
				MessageBox.Show(this, "Replaced " + cnt + " chunks.", "SonLVL-RSDK");
				DrawLevel();
			}
		}

		private void replaceBackgroundToolStripButton_Click(object sender, EventArgs e)
		{
			if (replaceBGChunksDialog.ShowDialog(this) == DialogResult.OK)
			{
				byte fc = (byte)replaceBGChunksDialog.findChunk.Value;
				byte rc = (byte)replaceBGChunksDialog.replaceChunk.Value;
				int cnt = 0;
				for (int y = 0; y < LevelData.BGHeight[bglayer]; y++)
					for (int x = 0; x < LevelData.BGWidth[bglayer]; x++)
						if (LevelData.Background.layers[bglayer].layout[y][x] == fc)
						{
							LevelData.Background.layers[bglayer].layout[y][x] = rc;
							cnt++;
						}
				MessageBox.Show(this, "Replaced " + cnt + " chunks.", "SonLVL-RSDK");
				DrawLevel();
			}
		}

		private void replaceChunkBlocksToolStripButton_Click(object sender, EventArgs e)
		{
			if (replaceChunkBlocksDialog.ShowDialog(this) == DialogResult.OK)
			{
				var list = LevelData.Chunks.SelectMany((a, b) => a.Blocks.OfType<ChunkBlock>().Select(c => new KeyValuePair<int, ChunkBlock>(b, c))).ToList();
				ushort? block = replaceChunkBlocksDialog.findBlock.Block;
				if (block.HasValue)
					list = list.Where(a => a.Value.Block == block.Value).ToList();
				bool? xflip = replaceChunkBlocksDialog.findBlock.XFlip;
				if (xflip.HasValue)
					list = list.Where(a => a.Value.XFlip == xflip.Value).ToList();
				bool? yflip = replaceChunkBlocksDialog.findBlock.YFlip;
				if (yflip.HasValue)
					list = list.Where(a => a.Value.YFlip = yflip.Value).ToList();
				Solidity? solid1 = replaceChunkBlocksDialog.findBlock.Solidity1;
				if (solid1.HasValue)
					list = list.Where(a => a.Value.Solid1 == solid1.Value).ToList();
				Solidity? solid2 = replaceChunkBlocksDialog.findBlock.Solidity2;
				if (solid2.HasValue)
					list = list.Where(a => ((S2ChunkBlock)a.Value).Solid2 == solid2.Value).ToList();
				block = replaceChunkBlocksDialog.replaceBlock.Block;
				xflip = replaceChunkBlocksDialog.replaceBlock.XFlip;
				yflip = replaceChunkBlocksDialog.replaceBlock.YFlip;
				solid1 = replaceChunkBlocksDialog.replaceBlock.Solidity1;
				solid2 = replaceChunkBlocksDialog.replaceBlock.Solidity2;
				foreach (ChunkBlock blk in list.Select(a => a.Value))
				{
					if (block.HasValue)
						blk.Block = block.Value;
					if (xflip.HasValue)
						blk.XFlip = xflip.Value;
					if (yflip.HasValue)
						blk.YFlip = yflip.Value;
					if (solid1.HasValue)
						blk.Solid1 = solid1.Value;
					if (solid2.HasValue)
						((S2ChunkBlock)blk).Solid2 = solid2.Value;
				}
				foreach (int i in list.Select(a => a.Key).Distinct())
					LevelData.RedrawChunk(i);
				ChunkSelector.Invalidate();
				DrawChunkPicture();
				chunkBlockEditor.SelectedObjects = chunkBlockEditor.SelectedObjects;
				MessageBox.Show(this, "Replaced " + list.Count + " chunk blocks.", "SonLVL-RSDK");
			}
		}

		private void removeDuplicateChunksToolStripButton_Click(object sender, EventArgs e)
		{
			if (MessageBox.Show(this, "This action may break other levels that share the same chunk set, or levels that alter the level layout dynamically.\n\nAre you sure you want to remove all duplicate chunks?", "SonLVL-RSDK", MessageBoxButtons.OKCancel) != DialogResult.OK)
				return;
			Dictionary<ushort, byte[]> chunks = new Dictionary<ushort, byte[]>(LevelData.NewChunks.chunkList.Length);
			Dictionary<ushort, ushort> chunkMap = new Dictionary<ushort, ushort>(LevelData.NewChunks.chunkList.Length);
			Stack<int> deleted = new Stack<int>();
			for (int i = 0; i < LevelData.NewChunks.chunkList.Length; i++)
			{
				byte[] cnk = LevelData.NewChunks.chunkList[i].GetBytes();
				foreach (var item in chunks)
					if (cnk.FastArrayEqual(item.Value))
					{
						chunkMap[(ushort)i] = item.Key;
						deleted.Push(i);
						break;
					}
				if (!chunkMap.ContainsKey((ushort)i))
				{
					chunkMap[(ushort)i] = (ushort)chunks.Count;
					chunks[(ushort)chunks.Count] = cnk;
				}
			}
			if (deleted.Count > 0)
			{
				foreach (int i in deleted)
				{
					LevelData.Chunks.RemoveAt(i);
				}
				ChunkID.Maximum = LevelData.NewChunks.chunkList.Length;
				ChunkSelector.SelectedIndex = Math.Min(ChunkSelector.SelectedIndex, LevelData.NewChunks.chunkList.Length - 1);
				LevelData.RemapLayouts((layout, x, y) =>
				{
					if (chunkMap.ContainsKey(layout[y][x]))
						layout[y][x] = chunkMap[layout[y][x]];
				});
				DrawLevel();
			}
			MessageBox.Show(this, "Removed " + deleted.Count + " duplicate chunks.", "SonLVL-RSDK");
		}

		private void flipChunkBlocksHorizontallyToolStripMenuItem_Click(object sender, EventArgs e)
		{
			switch (chunkBlockMenuMode)
			{
				case ChunkBlockMenuMode.Chunks:
					Chunk chunk = LevelData.NewChunks.chunkList[SelectedChunk];
					ChunkBlock[,] blocks = (ChunkBlock[,])chunk.Blocks.Clone();
					for (int y = 0; y < SelectedChunkBlock.Height; y++)
						for (int x = 0; x < SelectedChunkBlock.Width; x++)
						{
							ChunkBlock blk = blocks[SelectedChunkBlock.Right - 1 - x, SelectedChunkBlock.Y + y];
							blk.XFlip = !blk.XFlip;
							chunk.tiles[SelectedChunkBlock.Y + y][SelectedChunkBlock.X + x] = blk;
						}
					LevelData.RedrawChunk(SelectedChunk);
					copiedChunkBlock = (chunkBlockEditor.SelectedObjects = GetSelectedChunkBlocks())[0];
					/*if (copiedChunkBlock.tileIndex < LevelData.NewTiles.Length)
						TileSelector.SelectedIndex = chunk.tiles[SelectedChunkBlock.Y][SelectedChunkBlock.X].tileIndex;*/
					ChunkSelector.Invalidate();
					DrawChunkPicture();
					break;
			}
		}

		private void flipChunkBlocksVerticallyToolStripMenuItem_Click(object sender, EventArgs e)
		{
			switch (chunkBlockMenuMode)
			{
				case ChunkBlockMenuMode.Chunks:
					Chunk chunk = LevelData.NewChunks.chunkList[SelectedChunk];
					ChunkBlock[,] blocks = (ChunkBlock[,])chunk.Blocks.Clone();
					for (int y = 0; y < SelectedChunkBlock.Height; y++)
						for (int x = 0; x < SelectedChunkBlock.Width; x++)
						{
							ChunkBlock blk = blocks[SelectedChunkBlock.X + x, SelectedChunkBlock.Bottom - 1 - y];
							blk.YFlip = !blk.YFlip;
							chunk.tiles[SelectedChunkBlock.Y + y][SelectedChunkBlock.X + x] = blk;
						}
					LevelData.RedrawChunk(SelectedChunk);
					copiedChunkBlock = (chunkBlockEditor.SelectedObjects = GetSelectedChunkBlocks())[0];
					/*if (copiedChunkBlock.tileIndex < LevelData.NewTiles.Length)
						TileSelector.SelectedIndex = chunk.tiles[SelectedChunkBlock.Y][SelectedChunkBlock.X].tileIndex;*/
					ChunkSelector.Invalidate();
					DrawChunkPicture();
					break;
			}
		}

		private void copyChunkBlocksToolStripMenuItem_Click(object sender, EventArgs e)
		{
			switch (chunkBlockMenuMode)
			{
				case ChunkBlockMenuMode.Chunks:
					Chunk chunk = LevelData.NewChunks.chunkList[SelectedChunk];
					ChunkBlock[,] blocks = new ChunkBlock[SelectedChunkBlock.Width, SelectedChunkBlock.Height];
					for (int y = 0; y < SelectedChunkBlock.Height; y++)
						for (int x = 0; x < SelectedChunkBlock.Width; x++)
							blocks[x, y] = chunk.tiles[SelectedChunkBlock.Y + y][SelectedChunkBlock.X + x];
					Clipboard.SetData(ChunkBlock.GetTypeForFormat().MakeArrayType(2).AssemblyQualifiedName, blocks);
					break;
			}
		}

		private void pasteChunkBlocksToolStripMenuItem_Click(object sender, EventArgs e)
		{
			switch (chunkBlockMenuMode)
			{
				case ChunkBlockMenuMode.Chunks:
					Chunk chunk = LevelData.NewChunks.chunkList[SelectedChunk];
					ChunkBlock[,] blocks = (ChunkBlock[,])Clipboard.GetData(ChunkBlock.GetTypeForFormat().MakeArrayType(2).AssemblyQualifiedName);
					for (int y = 0; y < Math.Min(blocks.GetLength(1), (128 / 16) - SelectedChunkBlock.Y); y++)
						for (int x = 0; x < Math.Min(blocks.GetLength(0), (128 / 16) - SelectedChunkBlock.X); x++)
							chunk.tiles[SelectedChunkBlock.Y + y][SelectedChunkBlock.X + x] = blocks[x, y].Clone();
					LevelData.RedrawChunk(SelectedChunk);
					copiedChunkBlock = (chunkBlockEditor.SelectedObjects = GetSelectedChunkBlocks())[0];
					/*if (copiedChunkBlock.tileIndex < LevelData.NewTiles.Length)
						TileSelector.SelectedIndex = chunk.tiles[SelectedChunkBlock.Y][SelectedChunkBlock.X].tileIndex;*/
					ChunkSelector.Invalidate();
					DrawChunkPicture();
					break;
			}
		}

		private void clearChunkBlocksToolStripMenuItem_Click(object sender, EventArgs e)
		{
			switch (chunkBlockMenuMode)
			{
				case ChunkBlockMenuMode.Chunks:
					Chunk chunk = LevelData.NewChunks.chunkList[SelectedChunk];
					for (int y = 0; y < SelectedChunkBlock.Height; y++)
						for (int x = 0; x < SelectedChunkBlock.Width; x++)
							chunk.tiles[SelectedChunkBlock.Y + y][SelectedChunkBlock.X + x] = ChunkBlock.Create();
					LevelData.RedrawChunk(SelectedChunk);
					copiedChunkBlock = (chunkBlockEditor.SelectedObjects = GetSelectedChunkBlocks())[0];
					/*if (copiedChunkBlock.tileIndex < LevelData.NewTiles.Length)
						TileSelector.SelectedIndex = chunk.tiles[SelectedChunkBlock.Y][SelectedChunkBlock.X].tileIndex;*/
					ChunkSelector.Invalidate();
					DrawChunkPicture();
					break;
			}
		}

		private void ChunkID_ValueChanged(object sender, EventArgs e)
		{
			ChunkSelector.SelectedIndex = (int)ChunkID.Value;
		}

		private void TileID_ValueChanged(object sender, EventArgs e)
		{
			TileSelector.SelectedIndex = (int)(LevelData.Level.TwoPlayerCompatible ? TileID.Value / 2 : TileID.Value);
		}

		private void ColID_ValueChanged(object sender, EventArgs e)
		{
			CollisionSelector.SelectedIndex = (int)ColID.Value;
		}

		private void ExportTileToolStripMenuItem_Click(object sender, EventArgs e)
		{
			switch (CurrentArtTab)
			{
				case ArtTab.Chunks:
					if (!highToolStripMenuItem.Checked && !lowToolStripMenuItem.Checked && !path1ToolStripMenuItem.Checked && !path2ToolStripMenuItem.Checked)
					{
						MessageBox.Show(this, "Cannot export chunk with nothing visible.", Text, MessageBoxButtons.OK, MessageBoxIcon.Warning);
						return;
					}
					using (SaveFileDialog a = new SaveFileDialog() { FileName = (useHexadecimalIndexesToolStripMenuItem.Checked ? SelectedChunk.ToString("X2") : SelectedChunk.ToString()) + ".png", Filter = "PNG Images|*.png" })
						if (a.ShowDialog() == DialogResult.OK)
						{
							ColorPalette pal;
							using (Bitmap bmp = new Bitmap(1, 1, PixelFormat.Format8bppIndexed))
								pal = bmp.Palette;
							for (int i = 0; i < 64; i++)
								pal.Entries[i] = LevelData.PaletteToColor(i / 16, i % 16, transparentBackgroundToolStripMenuItem.Checked);
							pal.Entries.Fill(Color.Black, 64, 192);
							BitmapBits bits = null;
							string pathBase = Path.ChangeExtension(a.FileName, null);
							if (exportArtcollisionpriorityToolStripMenuItem.Checked)
							{
								bits = new BitmapBits(128, 128);
								bits.DrawSprite(LevelData.ChunkSprites[SelectedChunk]);
								bits.ToBitmap(pal).Save(pathBase + ".png");
								bool dualPath = false;
								switch (LevelData.Level.ChunkFormat)
								{
									case EngineVersion.S2:
									case EngineVersion.S2NA:
									case EngineVersion.S3K:
									case EngineVersion.SKC:
										dualPath = !Object.ReferenceEquals(LevelData.ColInds1, LevelData.ColInds2);
										break;
								}
								if (dualPath)
								{
									bits = new BitmapBits(LevelData.ChunkColBmpBits[SelectedChunk][0]);
									bits.UnfixUIColors();
									bits.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col1.png");
									bits = new BitmapBits(LevelData.ChunkColBmpBits[SelectedChunk][1]);
									bits.UnfixUIColors();
									bits.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col2.png");
								}
								else
								{
									bits = new BitmapBits(LevelData.ChunkColBmpBits[SelectedChunk][0]);
									bits.UnfixUIColors();
									bits.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col.png");
								}
								bits = new BitmapBits(128, 128);
								for (int cy = 0; cy < 128 / 16; cy++)
									for (int cx = 0; cx < 128 / 16; cx++)
									{
										if (LevelData.NewChunks.chunkList[SelectedChunk].tiles[cy][cx].tileIndex >= LevelData.NewTiles.Length) continue;
										Block blk = LevelData.NewTiles[LevelData.NewChunks.chunkList[SelectedChunk].tiles[cy][cx].tileIndex];
										for (int by = 0; by < 2; by++)
											for (int bx = 0; bx < 2; bx++)
												if (blk.Tiles[bx, by].Priority)
													bits.FillRectangle(1, cx * 16 + bx * 8, cy * 16 + by * 8, 8, 8);
									}
								bits.ToBitmap1bpp(Color.Black, Color.White).Save(pathBase + "_pri.png");
							}
							else
							{
								bits = new BitmapBits(128, 128);
								if (highToolStripMenuItem.Checked & lowToolStripMenuItem.Checked)
									bits.DrawSprite(LevelData.ChunkSprites[SelectedChunk]);
								else if (lowToolStripMenuItem.Checked)
									bits.DrawSpriteLow(LevelData.ChunkSprites[SelectedChunk]);
								else if (highToolStripMenuItem.Checked)
									bits.DrawSpriteHigh(LevelData.ChunkSprites[SelectedChunk]);
								if (path1ToolStripMenuItem.Checked)
									bits.DrawBitmapComposited(LevelData.ChunkColBmpBits[SelectedChunk][0], 0, 0);
								else if (path2ToolStripMenuItem.Checked)
									bits.DrawBitmapComposited(LevelData.ChunkColBmpBits[SelectedChunk][1], 0, 0);
								bits.ToBitmap(pal).Save(pathBase + ".png");
							}
						}
					break;
				case ArtTab.Tiles:
					using (SaveFileDialog a = new SaveFileDialog() { FileName = (useHexadecimalIndexesToolStripMenuItem.Checked ? SelectedTile.ToString("X2") : SelectedTile.ToString()) + ".png", Filter = "PNG Images|*.png" })
						if (a.ShowDialog() == DialogResult.OK)
							LevelData.TileToBmp4bpp(LevelData.Tiles[SelectedTile], 0, SelectedColor.Y, transparentBackgroundToolStripMenuItem.Checked)
								.Save(a.FileName);
					break;
			}
		}

		private void ExportLayoutSectionToolStripMenuItem_Click(object sender, EventArgs e)
		{
			using (SaveFileDialog a = new SaveFileDialog()
			{
				DefaultExt = "png",
				Filter = "PNG Files|*.png",
				RestoreDirectory = true
			})
				if (a.ShowDialog() == DialogResult.OK)
				{
					switch (CurrentTab)
					{
						case Tab.Foreground:
							if (exportArtcollisionpriorityToolStripMenuItem.Checked)
							{
								string pathBase = Path.Combine(Path.GetDirectoryName(a.FileName), Path.GetFileNameWithoutExtension(a.FileName));
								string pathExt = Path.GetExtension(a.FileName);
								BitmapBits bmp = LevelData.DrawForeground(FGSelection, false, false, true, true, false, false);
								for (int i = 0; i < bmp.Bits.Length; i++)
									if (bmp.Bits[i] == 0)
										bmp.Bits[i] = 32;
								int w = LevelData.WaterHeight - (FGSelection.Top * 128);
								if (LevelData.WaterPalette != -1 && bmp.Height > w)
									bmp.ApplyWaterPalette(w);
								Bitmap res = bmp.ToBitmap();
								ColorPalette pal = res.Palette;
								for (int i = 0; i < 64; i++)
									pal.Entries[i] = LevelData.PaletteToColor(i / 16, i % 16, transparentBackgroundToolStripMenuItem.Checked);
								pal.Entries.Fill(Color.Black, 64, 192);
								if (LevelData.WaterPalette != -1)
									for (int i = 128; i < 192; i++)
										if (transparentBackgroundToolStripMenuItem.Checked && i % 16 == 0)
											pal.Entries[i] = Color.Transparent;
										else
											pal.Entries[i] = LevelData.Palette[LevelData.WaterPalette][(i - 128) / 16, i % 16].RGBColor;
								res.Palette = pal;
								res.Save(a.FileName);
								bool dualPath = false;
								switch (LevelData.Level.ChunkFormat)
								{
									case EngineVersion.S2:
									case EngineVersion.S2NA:
									case EngineVersion.S3K:
									case EngineVersion.SKC:
										dualPath = !Object.ReferenceEquals(LevelData.ColInds1, LevelData.ColInds2);
										break;
								}
								if (dualPath)
								{
									bmp = LevelData.DrawForeground(FGSelection, false, false, false, false, true, false);
									bmp.UnfixUIColors();
									bmp.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col1" + pathExt);
									bmp = LevelData.DrawForeground(FGSelection, false, false, false, false, false, true);
									bmp.UnfixUIColors();
									bmp.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col2" + pathExt);
								}
								else if (LevelData.LayoutFormat.HasLoopFlag && LevelData.Layout.FGLoop.OfType<bool>().Any(b => b))
								{
									bmp = LevelData.DrawForeground(FGSelection, false, false, false, false, true, false);
									bmp.UnfixUIColors();
									bmp.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col1" + pathExt);
									ushort[,] copy = (ushort[,])LevelData.Layout.FGLayout.Clone();
									for (int y = FGSelection.Top; y < FGSelection.Bottom; y++)
										for (int x = FGSelection.Left; x < FGSelection.Right; x++)
											if (LevelData.Layout.FGLoop[x, y])
												LevelData.Scene.layout[y][x]++;
									bmp = LevelData.DrawForeground(FGSelection, false, false, false, false, true, false);
									bmp.UnfixUIColors();
									bmp.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col2" + pathExt);
									LevelData.Layout.FGLayout = copy;
								}
								else
								{
									bmp = LevelData.DrawForeground(FGSelection, false, false, false, false, true, false);
									bmp.UnfixUIColors();
									bmp.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col" + pathExt);
								}
								bmp.Clear();
								int l = FGSelection.Left * 128;
								int t = FGSelection.Top * 128;
								for (int ly = FGSelection.Top; ly < FGSelection.Bottom; ly++)
									for (int lx = FGSelection.Left; lx < FGSelection.Right; lx++)
									{
										if (LevelData.Scene.layout[ly][lx] >= LevelData.NewChunks.chunkList.Length) continue;
										Chunk cnk = LevelData.NewChunks.chunkList[LevelData.Scene.layout[ly][lx]];
										for (int cy = 0; cy < 128 / 16; cy++)
											for (int cx = 0; cx < 128 / 16; cx++)
											{
												if (cnk.tiles[cy][cx].tileIndex >= LevelData.NewTiles.Length) continue;
												Block blk = LevelData.NewTiles[cnk.tiles[cy][cx].tileIndex];
												for (int by = 0; by < 2; by++)
													for (int bx = 0; bx < 2; bx++)
														if (blk.Tiles[bx, by].Priority)
															bmp.FillRectangle(1, lx * 128 + cx * 16 + bx * 8 - l, ly * 128 + cy * 16 + by * 8 - t, 8, 8);
											}
									}
								bmp.ToBitmap1bpp(Color.Black, Color.White).Save(pathBase + "_pri" + pathExt);
							}
							else
							{
								BitmapBits bmp = LevelData.DrawForeground(FGSelection, includeobjectsWithFGToolStripMenuItem.Checked, objectsAboveHighPlaneToolStripMenuItem.Checked, lowToolStripMenuItem.Checked, highToolStripMenuItem.Checked, path1ToolStripMenuItem.Checked, path2ToolStripMenuItem.Checked);
								int w = LevelData.WaterHeight - (FGSelection.Top * 128);
								if (LevelData.WaterPalette != -1 && bmp.Height > w)
									bmp.ApplyWaterPalette(w);
								using (Bitmap res = bmp.ToBitmap(LevelImgPalette))
									res.Save(a.FileName);
							}
							break;
						case Tab.Background:
							if (exportArtcollisionpriorityToolStripMenuItem.Checked)
							{
								string pathBase = Path.Combine(Path.GetDirectoryName(a.FileName), Path.GetFileNameWithoutExtension(a.FileName));
								string pathExt = Path.GetExtension(a.FileName);
								BitmapBits bmp = LevelData.DrawBackground(TODO, BGSelection, true, true, false, false);
								for (int i = 0; i < bmp.Bits.Length; i++)
									if (bmp.Bits[i] == 0)
										bmp.Bits[i] = 32;
								Bitmap res = bmp.ToBitmap();
								ColorPalette pal = res.Palette;
								for (int i = 0; i < 64; i++)
									pal.Entries[i] = LevelData.PaletteToColor(i / 16, i % 16, transparentBackgroundToolStripMenuItem.Checked);
								pal.Entries.Fill(Color.Black, 64, 192);
								res.Palette = pal;
								res.Save(a.FileName);
								bool dualPath = false;
								switch (LevelData.Level.ChunkFormat)
								{
									case EngineVersion.S2:
									case EngineVersion.S2NA:
									case EngineVersion.S3K:
									case EngineVersion.SKC:
										dualPath = !Object.ReferenceEquals(LevelData.ColInds1, LevelData.ColInds2);
										break;
								}
								if (dualPath)
								{
									bmp = LevelData.DrawBackground(TODO, BGSelection, false, false, true, false);
									bmp.UnfixUIColors();
									bmp.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col1" + pathExt);
									bmp = LevelData.DrawBackground(TODO, BGSelection, false, false, false, true);
									bmp.UnfixUIColors();
									bmp.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col2" + pathExt);
								}
								else if (LevelData.LayoutFormat.HasLoopFlag && LevelData.Layout.BGLoop.OfType<bool>().Any(b => b))
								{
									bmp = LevelData.DrawBackground(TODO, BGSelection, false, false, true, false);
									bmp.UnfixUIColors();
									bmp.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col1" + pathExt);
									ushort[,] copy = (ushort[,])LevelData.Layout.BGLayout.Clone();
									for (int y = BGSelection.Top; y < BGSelection.Bottom; y++)
										for (int x = BGSelection.Left; x < BGSelection.Right; x++)
											if (LevelData.Layout.BGLoop[x, y])
												LevelData.Background.layers[bglayer].layout[y][x]++;
									bmp = LevelData.DrawBackground(TODO, BGSelection, false, false, true, false);
									bmp.UnfixUIColors();
									bmp.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col2" + pathExt);
									LevelData.Layout.BGLayout = copy;
								}
								else
								{
									bmp = LevelData.DrawBackground(TODO, BGSelection, false, false, true, false);
									bmp.UnfixUIColors();
									bmp.ToBitmap4bpp(Color.Magenta, Color.White, Color.Yellow, Color.Black).Save(pathBase + "_col" + pathExt);
								}
								bmp.Clear();
								int l = BGSelection.Left * 128;
								int t = BGSelection.Top * 128;
								for (int ly = BGSelection.Top; ly < BGSelection.Bottom; ly++)
									for (int lx = BGSelection.Left; lx < BGSelection.Right; lx++)
									{
										if (LevelData.Background.layers[bglayer].layout[ly][lx] >= LevelData.NewChunks.chunkList.Length) continue;
										Chunk cnk = LevelData.NewChunks.chunkList[LevelData.Background.layers[bglayer].layout[ly][lx]];
										for (int cy = 0; cy < 128 / 16; cy++)
											for (int cx = 0; cx < 128 / 16; cx++)
											{
												if (cnk.tiles[cy][cx].tileIndex >= LevelData.NewTiles.Length) continue;
												Block blk = LevelData.NewTiles[cnk.tiles[cy][cx].tileIndex];
												for (int by = 0; by < 2; by++)
													for (int bx = 0; bx < 2; bx++)
														if (blk.Tiles[bx, by].Priority)
															bmp.FillRectangle(1, lx * 128 + cx * 16 + bx * 8 - l, ly * 128 + cy * 16 + by * 8 - t, 8, 8);
											}
									}
								bmp.ToBitmap1bpp(Color.Black, Color.White).Save(pathBase + "_pri" + pathExt);
							}
							else
							{
								BitmapBits bmp = LevelData.DrawBackground(TODO, BGSelection, lowToolStripMenuItem.Checked, highToolStripMenuItem.Checked, path1ToolStripMenuItem.Checked, path2ToolStripMenuItem.Checked);
								using (Bitmap res = bmp.ToBitmap(LevelImgPalette))
									res.Save(a.FileName);
							}
							break;
					}
				}
		}

		private void removeDuplicateTilesToolStripButton_Click(object sender, EventArgs e)
		{
			if (MessageBox.Show(this, "This action may break other levels that share part of the same tile set, or objects that have their art in this set.\n\nAre you sure you want to remove all duplicate tiles?", "SonLVL-RSDK", MessageBoxButtons.OKCancel) != DialogResult.OK)
				return;
			if (LevelData.Level.TwoPlayerCompatible)
			{
				Dictionary<ushort, byte[]> tiles = new Dictionary<ushort, byte[]>(LevelData.NewTiles.Length / 2);
				Dictionary<ushort, PatternIndex> tileMap = new Dictionary<ushort, PatternIndex>(LevelData.NewTiles.Length / 2);
				Stack<int> deleted = new Stack<int>();
				for (int i = 0; i < LevelData.NewTiles.Length; i += 2)
				{
					byte[] tile = new byte[64];
					Array.Copy(LevelData.TileArray, i * 32, tile, 0, 64);
					byte[] tileh = LevelData.FlipTileInterlaced(tile, true, false);
					byte[] tilev = LevelData.FlipTileInterlaced(tile, false, true);
					byte[] tilehv = LevelData.FlipTileInterlaced(tile, true, true);
					foreach (var item in tiles)
					{
						if (tile.FastArrayEqual(item.Value))
						{
							tileMap[(ushort)i] = new PatternIndex() { Tile = item.Key };
							deleted.Push(i);
							break;
						}
						if (tileh.FastArrayEqual(item.Value))
						{
							tileMap[(ushort)i] = new PatternIndex() { Tile = item.Key, XFlip = true };
							deleted.Push(i);
							break;
						}
						if (tilev.FastArrayEqual(item.Value))
						{
							tileMap[(ushort)i] = new PatternIndex() { Tile = item.Key, YFlip = true };
							deleted.Push(i);
							break;
						}
						if (tilehv.FastArrayEqual(item.Value))
						{
							tileMap[(ushort)i] = new PatternIndex() { Tile = item.Key, XFlip = true, YFlip = true };
							deleted.Push(i);
							break;
						}
					}
					if (!tileMap.ContainsKey((ushort)i))
					{
						tileMap[(ushort)i] = new PatternIndex() { Tile = (ushort)(tiles.Count * 2) };
						tiles[(ushort)(tiles.Count * 2)] = tile;
					}
				}
				if (deleted.Count > 0)
				{
					foreach (int i in deleted)
					{
						LevelData.Tiles.RemoveAt(i);
						LevelData.Tiles.RemoveAt(i);
					}
					LevelData.UpdateTileArray();
					TileID.Maximum = LevelData.NewTiles.Length - 1;
					RefreshTileSelector();
					TileSelector.SelectedIndex = Math.Min(TileSelector.SelectedIndex, TileSelector.Images.Count - 1);
					for (int i = 0; i < LevelData.NewTiles.Length; i++)
						for (int x = 0; x < 2; x++)
							if (tileMap.ContainsKey((ushort)(LevelData.NewTiles[i].Tiles[x, 0].Tile & ~1)))
							{
								PatternIndex nb = tileMap[(ushort)(LevelData.NewTiles[i].Tiles[x, 0].Tile & ~1)];
								LevelData.NewTiles[i].Tiles[x, 0].Tile = nb.Tile;
								LevelData.NewTiles[i].Tiles[x, 0].XFlip ^= nb.XFlip;
								LevelData.NewTiles[i].Tiles[x, 0].YFlip ^= nb.YFlip;
								LevelData.NewTiles[i].MakeInterlacedCompatible();
							}
					chunkBlockEditor.SelectedObjects = chunkBlockEditor.SelectedObjects;
					DrawLevel();
				}
				MessageBox.Show(this, "Removed " + deleted.Count + " duplicate tiles.", "SonLVL-RSDK");
			}
			else
			{
				Dictionary<ushort, byte[]> tiles = new Dictionary<ushort, byte[]>(LevelData.NewTiles.Length);
				Dictionary<ushort, PatternIndex> tileMap = new Dictionary<ushort, PatternIndex>(LevelData.NewTiles.Length);
				Stack<int> deleted = new Stack<int>();
				for (int i = 0; i < LevelData.NewTiles.Length; i++)
				{
					byte[] tile = LevelData.Tiles[i];
					byte[] tileh = LevelData.FlipTile(tile, true, false);
					byte[] tilev = LevelData.FlipTile(tile, false, true);
					byte[] tilehv = LevelData.FlipTile(tile, true, true);
					foreach (var item in tiles)
					{
						if (tile.FastArrayEqual(item.Value))
						{
							tileMap[(ushort)i] = new PatternIndex() { Tile = item.Key };
							deleted.Push(i);
							break;
						}
						if (tileh.FastArrayEqual(item.Value))
						{
							tileMap[(ushort)i] = new PatternIndex() { Tile = item.Key, XFlip = true };
							deleted.Push(i);
							break;
						}
						if (tilev.FastArrayEqual(item.Value))
						{
							tileMap[(ushort)i] = new PatternIndex() { Tile = item.Key, YFlip = true };
							deleted.Push(i);
							break;
						}
						if (tilehv.FastArrayEqual(item.Value))
						{
							tileMap[(ushort)i] = new PatternIndex() { Tile = item.Key, XFlip = true, YFlip = true };
							deleted.Push(i);
							break;
						}
					}
					if (!tileMap.ContainsKey((ushort)i))
					{
						tileMap[(ushort)i] = new PatternIndex() { Tile = (ushort)tiles.Count };
						tiles[(ushort)tiles.Count] = tile;
					}
				}
				if (deleted.Count > 0)
				{
					foreach (int i in deleted)
					{
						LevelData.Tiles.RemoveAt(i);
						TileSelector.Images.RemoveAt(i);
					}
					LevelData.UpdateTileArray();
					TileID.Maximum = LevelData.NewTiles.Length - 1;
					TileSelector.SelectedIndex = Math.Min(TileSelector.SelectedIndex, LevelData.NewTiles.Length - 1);
					for (int i = 0; i < LevelData.NewTiles.Length; i++)
						foreach (PatternIndex cb in LevelData.NewTiles[i].Tiles)
							if (tileMap.ContainsKey(cb.Tile))
							{
								PatternIndex nb = tileMap[cb.Tile];
								cb.Tile = nb.Tile;
								cb.XFlip ^= nb.XFlip;
								cb.YFlip ^= nb.YFlip;
							}
					chunkBlockEditor.SelectedObjects = chunkBlockEditor.SelectedObjects;
					DrawLevel();
				}
				MessageBox.Show(this, "Removed " + deleted.Count + " duplicate tiles.", "SonLVL-RSDK");
			}
		}

		private void importOverToolStripMenuItem_Click(object sender, EventArgs e)
		{
			using (OpenFileDialog opendlg = new OpenFileDialog())
			{
				opendlg.DefaultExt = "png";
				opendlg.Filter = "Image Files|*.bmp;*.png;*.jpg;*.gif";
				opendlg.RestoreDirectory = true;
				if (opendlg.ShowDialog(this) == DialogResult.OK)
				{
					BitmapInfo bmpi;
					using (Bitmap bmp = new Bitmap(opendlg.FileName))
						bmpi = new BitmapInfo(bmp);
					switch (CurrentArtTab)
					{
						case ArtTab.Chunks:
							if (bmpi.Width < 128 || bmpi.Height < 128)
							{
								MessageBox.Show(this, "Image must be at least " + 128 + "x" + 128 + " to import chunk.", "SonLVL-RSDK");
								return;
							}
							break;
						case ArtTab.Tiles:
							if (bmpi.Width < 8 || bmpi.Height < (LevelData.Level.TwoPlayerCompatible ? 16 : 8))
							{
								MessageBox.Show(this, "Image must be at least 8x" + (LevelData.Level.TwoPlayerCompatible ? "16" : "8") + " to import tile.", "SonLVL-RSDK");
								return;
							}
							break;
					}
					ImportResult res = LevelData.BitmapToTiles(bmpi, new bool[bmpi.Width / 8, bmpi.Height / 8], blockcolinfo, null, new List<byte[]>(), TODO, false, Application.DoEvents);
					List<int> editedTiles = new List<int>();
					switch (CurrentArtTab)
					{
						case ArtTab.Chunks:
							Chunk cnk = LevelData.NewChunks.chunkList[SelectedChunk];
							for (int by = 0; by < 128 / 16; by++)
								for (int bx = 0; bx < 128 / 16; bx++)
								{
									Block blk = LevelData.NewTiles[cnk.tiles[by][bx].tileIndex].Flip(cnk.tiles[by][bx].XFlip, cnk.tiles[by][bx].YFlip);
									for (int y = 0; y < 2; y++)
										for (int x = 0; x < 2; x++)
											if (!editedTiles.Contains(blk.Tiles[x, y].Tile))
											{
												LevelData.Tiles[blk.Tiles[x, y].Tile] = LevelData.FlipTile(res.Art[res.Mappings[(bx * 2) + x, (by * 2) + y].Tile], blk.Tiles[x, y].XFlip, blk.Tiles[x, y].YFlip);
												editedTiles.Add(blk.Tiles[x, y].Tile);
											}
								}
							break;
						case ArtTab.Tiles:
							LevelData.Tiles[SelectedTile] = res.Art[res.Mappings[0, 0].Tile];
							editedTiles.Add(SelectedTile);
							if (LevelData.Level.TwoPlayerCompatible)
								LevelData.Tiles[SelectedTile + 1] = res.Art[res.Mappings[0, 1].Tile];
							break;
					}
					LevelData.UpdateTileArray();
					RefreshTileSelector();
					TileSelector.Invalidate();
					if (editedTiles.Contains(SelectedTile))
						TileSelector_SelectedIndexChanged(this, EventArgs.Empty);
					chunkBlockEditor.SelectedObjects = chunkBlockEditor.SelectedObjects;
					/*for (int i = 0; i < LevelData.NewChunks.chunkList.Length; i++)
						if (LevelData.NewChunks.chunkList[i].Blocks.OfType<ChunkBlock>().Any(a => editedBlocks.Contains(a.Block)))
						{
							LevelData.RedrawChunk(i);
							if (i == SelectedChunk)
								DrawChunkPicture();
						}*/
					ChunkSelector.Invalidate();
				}
			}
		}

		private void TileSelector_MouseDoubleClick(object sender, MouseEventArgs e)
		{
			if (loaded && e.Button == MouseButtons.Left)
				foreach (PatternIndex til in GetSelectedBlockTiles())
					til.Tile = (ushort)TileSelector.SelectedIndex;
		}
	}

	[Serializable]
	public class LayoutSection
	{
		public string Name { get; set; }
		public ushort[,] Layout { get; set; }
		public List<Entry> Objects { get; set; }

		public LayoutSection(ushort[,] layout, List<Entry> objects)
		{
			Layout = layout;
			Objects = objects;
		}
	}

	[Serializable]
	public class ChunkCopyData
	{
		public List<BitmapBits> Tiles { get; set; }
		public List<RSDKv3_4.TileConfig.CollisionMask[]> Collision { get; set; }
		public RSDKv3_4.Tiles128x128.Block Chunk { get; set; }

		public ChunkCopyData(RSDKv3_4.Tiles128x128.Block chunk)
		{
			Chunk = chunk.Clone();
			List<ushort> blocks = new List<ushort>();
			Collision = new List<RSDKv3_4.TileConfig.CollisionMask[]>();
			for (int y = 0; y < 8; y++)
				for (int x = 0; x < 8; x++)
					if (chunk.tiles[y][x].tileIndex < LevelData.NewTiles.Length)
					{
						int i = blocks.IndexOf(chunk.tiles[y][x].tileIndex);
						if (i == -1)
						{
							i = blocks.Count;
							blocks.Add(chunk.tiles[y][x].tileIndex);
						}
						Chunk.tiles[y][x].tileIndex = (ushort)i;
					}
			Tiles = blocks.Select(a => LevelData.NewTiles[a]).ToList();
			Collision = blocks.Select(a => new[] { LevelData.Collision.collisionMasks[0][a], LevelData.Collision.collisionMasks[1][a] }).ToList();
		}
	}

	class HUDImage
	{
		public Sprite Image { get; private set; }
		public int Width { get; private set; }
		public int Height { get; private set; }

		public HUDImage(BitmapBits image)
		{
			Image = new Sprite(image);
			Width = image.Width;
			Height = image.Height;
		}
	}
}
